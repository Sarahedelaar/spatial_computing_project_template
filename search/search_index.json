{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Spatial Computing Project \"Slime Mold\" Design problems? THe problem of the site was that... Design Challenge The objective is to design a housing complex incorporating several communal/public facilities for a cooperative live-work-play association. The housing complex is to accommodate students, young graduates (starters), and elderly. The complex also provides communal/public facilities, almost as a collective. Location: Rotterdam, the block between Vijverhofstraat, Zomerhofstraat, Schoterbosstraat, and Teilingerstraat (see Figure 1). The location is split into compulsory and optional development, . The part that is to be changed is the big multi-functional building, but if required, the old railway line, football park, restaurant and green park in the light green areas can be incorporated as well. If the design is extended into the optional parts, any streets or pathways crossing this region should be integrated into the design, without losing their original function. Location Location showing optional building plot The program of requirements lists the spaces below: Housing: Student Housing 80 units Assisted Living 30 units Starter Housing 100 units Communal Spaces: Underground Parking (minimum of 0.5 parking lots per apartment) Vegetation (minimum 30% of the plot) Workshops/Fab-Labs/Co-working Space and Start-up Offices Library + Cinematheque + Caf\u00e9/Pub + [pinball] Arcade Co-cooking/Restaurant Community Centre Shop (grocery, tools and crafts) [electricity producing/odourless /geek-friendly] Gym Design Goals (quantitative & qualitative): Maximum Multi-scale Modularity (Qualitative) Excellent Ergonomics (Qualitative) Keeping at least the same amount of housing units as before (Quantitative) Not blocking direct light for neighbour buildings (Quantitative) Max solar gain potential (optional, Quantitative) Max greenery (Quantitative) Min noise (Quantitative) Social integration (Qualitative) Rational spectra of privacy and community (Qualitative)","title":"Home"},{"location":"#spatial-computing-project-slime-mold","text":"","title":"Spatial Computing Project \"Slime Mold\""},{"location":"#design-problems","text":"THe problem of the site was that...","title":"Design problems?"},{"location":"#design-challenge","text":"The objective is to design a housing complex incorporating several communal/public facilities for a cooperative live-work-play association. The housing complex is to accommodate students, young graduates (starters), and elderly. The complex also provides communal/public facilities, almost as a collective. Location: Rotterdam, the block between Vijverhofstraat, Zomerhofstraat, Schoterbosstraat, and Teilingerstraat (see Figure 1). The location is split into compulsory and optional development, . The part that is to be changed is the big multi-functional building, but if required, the old railway line, football park, restaurant and green park in the light green areas can be incorporated as well. If the design is extended into the optional parts, any streets or pathways crossing this region should be integrated into the design, without losing their original function.","title":"Design Challenge"},{"location":"#location","text":"Location showing optional building plot The program of requirements lists the spaces below: Housing: Student Housing 80 units Assisted Living 30 units Starter Housing 100 units Communal Spaces: Underground Parking (minimum of 0.5 parking lots per apartment) Vegetation (minimum 30% of the plot) Workshops/Fab-Labs/Co-working Space and Start-up Offices Library + Cinematheque + Caf\u00e9/Pub + [pinball] Arcade Co-cooking/Restaurant Community Centre Shop (grocery, tools and crafts) [electricity producing/odourless /geek-friendly] Gym Design Goals (quantitative & qualitative): Maximum Multi-scale Modularity (Qualitative) Excellent Ergonomics (Qualitative) Keeping at least the same amount of housing units as before (Quantitative) Not blocking direct light for neighbour buildings (Quantitative) Max solar gain potential (optional, Quantitative) Max greenery (Quantitative) Min noise (Quantitative) Social integration (Qualitative) Rational spectra of privacy and community (Qualitative)","title":"Location"},{"location":"a1_planning/","text":"Planning Here you should include the process and product of your 1st activity: Planning Title Planning (process): Programme of Requirements & Network (product) Objective Formulate the design problems, form a programme of requirements, form a network, formulate your design principles and the idea (spatial sequences/experience/stories visible in a network). Procedure Describe the hierarchy of design decisions, formulate design goals, define design principles, identify stages in the design process that could be supported by algorithms, draw a flowchart to reflect on these steps and their connections and update it every week. Develop a programme of requirements, an idea (encapsulating the added value of the building and what is going to be unique about it in terms of human experiences) and a corresponding network indicating the main trips inside the building to be facilitated by direct connections matching with the scenarios envisaged in the idea. Formulate the design principles indicating what is a good shape for the building given operational, climatic, or structural aspects.","title":"Planning"},{"location":"a1_planning/#planning","text":"Here you should include the process and product of your 1st activity: Planning Title Planning (process): Programme of Requirements & Network (product) Objective Formulate the design problems, form a programme of requirements, form a network, formulate your design principles and the idea (spatial sequences/experience/stories visible in a network). Procedure Describe the hierarchy of design decisions, formulate design goals, define design principles, identify stages in the design process that could be supported by algorithms, draw a flowchart to reflect on these steps and their connections and update it every week. Develop a programme of requirements, an idea (encapsulating the added value of the building and what is going to be unique about it in terms of human experiences) and a corresponding network indicating the main trips inside the building to be facilitated by direct connections matching with the scenarios envisaged in the idea. Formulate the design principles indicating what is a good shape for the building given operational, climatic, or structural aspects.","title":"Planning"},{"location":"a2_configuring/","text":"Configuring Here you should include the process and product of your 2nd activity: Configuring Title Configuring (process): Circulation Manifold (product) Objective Formulate a spatial (topological) concept, design a modular circulation manifold on a pixel/voxel grid. Procedure Construct a voxelated model of the site with a maximum height of 100 meters. Orient the voxel grid to a global coordinate system (e.g. geographical North-East-West-South). Size the voxels carefully based on the modular height of steps and the length of stair flights and ramps so that they fit in X/Y directions into multiple pixels. Choose the Z size of voxels according to step risers and choose the same size for X and Y as a whole multiple of step threads. There are three types of spaces in terms of pedestrian movement in buildings, metaphorically speaking, spaces to walk through (e.g. corridors, ramps, and stairs), spaces to stand on (e.g. platforms connecting doors to corridors and stairs) and spaces to sit on (functional rooms/spaces). Construct a simplified mesh model of all bridges (corridors, ramps, stairs) connected by standing platforms in a modular grid of voxels/pixels. Take into account the free-height necessary for all spaces and pack them into the bounding volume of the building. For every functional space, leave a single pixel as a standing platform and colour it with the corresponding colour.","title":"Configuring"},{"location":"a2_configuring/#configuring","text":"Here you should include the process and product of your 2nd activity: Configuring Title Configuring (process): Circulation Manifold (product) Objective Formulate a spatial (topological) concept, design a modular circulation manifold on a pixel/voxel grid. Procedure Construct a voxelated model of the site with a maximum height of 100 meters. Orient the voxel grid to a global coordinate system (e.g. geographical North-East-West-South). Size the voxels carefully based on the modular height of steps and the length of stair flights and ramps so that they fit in X/Y directions into multiple pixels. Choose the Z size of voxels according to step risers and choose the same size for X and Y as a whole multiple of step threads. There are three types of spaces in terms of pedestrian movement in buildings, metaphorically speaking, spaces to walk through (e.g. corridors, ramps, and stairs), spaces to stand on (e.g. platforms connecting doors to corridors and stairs) and spaces to sit on (functional rooms/spaces). Construct a simplified mesh model of all bridges (corridors, ramps, stairs) connected by standing platforms in a modular grid of voxels/pixels. Take into account the free-height necessary for all spaces and pack them into the bounding volume of the building. For every functional space, leave a single pixel as a standing platform and colour it with the corresponding colour.","title":"Configuring"},{"location":"a3_massing/","text":"Massing Here you should include the process and product of your 3rd activity: Massing Title Massing (process): Composition (product) Objective Logically place the functional spaces in between bridges within the building envelope. Procedure Compute a Solar Envelope, i.e. an envelope of cuboids/voxels, some of which are removed because they are in the way of the neighbouring buildings receiving some standard/minimum level of direct sunlight. Fit the circulation manifold into the solar envelope. From the standing platforms corresponding to functional spaces, grow them into voxel clouds within your voxelated envelope. Colour the voxel clouds according to their functionalities.","title":"Massing"},{"location":"a3_massing/#massing","text":"Here you should include the process and product of your 3rd activity: Massing Title Massing (process): Composition (product) Objective Logically place the functional spaces in between bridges within the building envelope. Procedure Compute a Solar Envelope, i.e. an envelope of cuboids/voxels, some of which are removed because they are in the way of the neighbouring buildings receiving some standard/minimum level of direct sunlight. Fit the circulation manifold into the solar envelope. From the standing platforms corresponding to functional spaces, grow them into voxel clouds within your voxelated envelope. Colour the voxel clouds according to their functionalities.","title":"Massing"},{"location":"a4_forming/","text":"Forming Here you should include the process and product of your 4th activity: Forming Title Forming (process): Form (product) Objective Document the process and products and provide explanations to ensure reusability of materials. Procedure Finalize the plans and the forms of all functional units. Optionally, choose a way to alter the jaggedness of voxels in the final form by partially bringing in contrasting curvy shapes, for instance as a shell around the building, e.g. through smoothing, relaxation, iso-surfaces, or topological transformation.","title":"Forming"},{"location":"a4_forming/#forming","text":"Here you should include the process and product of your 4th activity: Forming Title Forming (process): Form (product) Objective Document the process and products and provide explanations to ensure reusability of materials. Procedure Finalize the plans and the forms of all functional units. Optionally, choose a way to alter the jaggedness of voxels in the final form by partially bringing in contrasting curvy shapes, for instance as a shell around the building, e.g. through smoothing, relaxation, iso-surfaces, or topological transformation.","title":"Forming"},{"location":"a5_finaldelivery/","text":"Final Deliveries","title":"Final Deliveries"},{"location":"a5_finaldelivery/#final-deliveries","text":"","title":"Final Deliveries"},{"location":"about/","text":"About Name Studentnumber Role Joris Ghobrial Title Diagrammer Youri Stoeller 5107490 Text Glenn Text Puzzle solver Sarah Edelaar 5038405 Puzzle solver Responsible instructor: Ir. P. Nourian (TU Delft, Design Informatics- PZN) Instructors: Ir. Shervin Azadi (TU Delft, Design Informatics - SAZ)","title":"About"},{"location":"about/#about","text":"Name Studentnumber Role Joris Ghobrial Title Diagrammer Youri Stoeller 5107490 Text Glenn Text Puzzle solver Sarah Edelaar 5038405 Puzzle solver Responsible instructor: Ir. P. Nourian (TU Delft, Design Informatics- PZN) Instructors: Ir. Shervin Azadi (TU Delft, Design Informatics - SAZ)","title":"About"},{"location":"Configuring/a2_configuring_process/","text":"Configuring: process Here you should include the process and product of your 2nd activity: Configuring Title Configuring (process): Circulation Manifold (product) Objective Formulate a spatial (topological) concept, design a modular circulation manifold on a pixel/voxel grid. Procedure Construct a voxelated model of the site with a maximum height of 100 meters. Orient the voxel grid to a global coordinate system (e.g. geographical North-East-West-South). Size the voxels carefully based on the modular height of steps and the length of stair flights and ramps so that they fit in X/Y directions into multiple pixels. Choose the Z size of voxels according to step risers and choose the same size for X and Y as a whole multiple of step threads. There are three types of spaces in terms of pedestrian movement in buildings, metaphorically speaking, spaces to walk through (e.g. corridors, ramps, and stairs), spaces to stand on (e.g. platforms connecting doors to corridors and stairs) and spaces to sit on (functional rooms/spaces). Construct a simplified mesh model of all bridges (corridors, ramps, stairs) connected by standing platforms in a modular grid of voxels/pixels. Take into account the free-height necessary for all spaces and pack them into the bounding volume of the building. For every functional space, leave a single pixel as a standing platform and colour it with the corresponding colour. Voxelized envelope low res The voxelized envelope consists of.................... (Fig. 1) Fig. 1 Voxelized envelope lowres Voxelized envelope high res The voxelized envelope consists of.................... (Fig. 2) Fig. 2 Voxelized envelope highres Voxel size The final voxel is 3.6*3.6*3.24 (w*d*h) meters. With the minivoxel being 0.9*0.9*0.54 (w*d*h) meters to represent a flight of three stairs. (Fig. 3) Fig. 3 Voxelsize","title":"Process"},{"location":"Configuring/a2_configuring_process/#configuring-process","text":"Here you should include the process and product of your 2nd activity: Configuring Title Configuring (process): Circulation Manifold (product) Objective Formulate a spatial (topological) concept, design a modular circulation manifold on a pixel/voxel grid. Procedure Construct a voxelated model of the site with a maximum height of 100 meters. Orient the voxel grid to a global coordinate system (e.g. geographical North-East-West-South). Size the voxels carefully based on the modular height of steps and the length of stair flights and ramps so that they fit in X/Y directions into multiple pixels. Choose the Z size of voxels according to step risers and choose the same size for X and Y as a whole multiple of step threads. There are three types of spaces in terms of pedestrian movement in buildings, metaphorically speaking, spaces to walk through (e.g. corridors, ramps, and stairs), spaces to stand on (e.g. platforms connecting doors to corridors and stairs) and spaces to sit on (functional rooms/spaces). Construct a simplified mesh model of all bridges (corridors, ramps, stairs) connected by standing platforms in a modular grid of voxels/pixels. Take into account the free-height necessary for all spaces and pack them into the bounding volume of the building. For every functional space, leave a single pixel as a standing platform and colour it with the corresponding colour.","title":"Configuring: process"},{"location":"Configuring/a2_configuring_process/#voxelized-envelope-low-res","text":"The voxelized envelope consists of.................... (Fig. 1) Fig. 1 Voxelized envelope lowres","title":"Voxelized envelope low res"},{"location":"Configuring/a2_configuring_process/#voxelized-envelope-high-res","text":"The voxelized envelope consists of.................... (Fig. 2) Fig. 2 Voxelized envelope highres","title":"Voxelized envelope high res"},{"location":"Configuring/a2_configuring_process/#voxel-size","text":"The final voxel is 3.6*3.6*3.24 (w*d*h) meters. With the minivoxel being 0.9*0.9*0.54 (w*d*h) meters to represent a flight of three stairs. (Fig. 3) Fig. 3 Voxelsize","title":"Voxel size"},{"location":"Configuring/a2_configuring_product/","text":"Configuring: product HIGH RES FIELDS, Flowcharts naar proces + schematische tekening Distance to main entrance For creating a distance field based on walking through the building, we first created two different neigbourhood stencils to work with. The first stencil shows that going one voxel sideways (in x- or y-direction) the value of the neighbours will increment with 1. However, when someone wants to go a level up or down, this costs more energy than walking on the same level. Therefore, the neighbours in the z-direction will increment with the value of 2. Voxels PSEUDO CODE NAKIJKEN Distance to Main Entrance Flowchart Distance to Main Entrance Flowchart Distance to Main Entrance Pseudo code 0. Distance to main entrance field Distance_to_main_entrance_field.py Input : voxelized_envelope . csv ( low and high res ), points of main street and public transport 1. Import Meshes 2. Import Lattice 3. Compute from each voxel the average distance to the main street and public transport Choose the voxel with the minimum distance as the main entrance Retrieve the neighbour voxels of the main entrance Set the value of the horizontal neighbours to 1 and the vertical neighbours to 2 For each neighbour : Find the neighbours and add 1 ( horizontal ) or 2 ( vertical ) to it \u2019 s value , when it does not have a value yet Convert the values into values between 0 and 1 4. Construct the field Output : Distance to main entrance field ( low and high res ) Distance to the ground PSEUDO CODE AANPASSEN Distance to Ground Distance to Ground Flowchart Distance to Ground Pseudo code 0. Distance to ground field Distance_to_ground_field.py Input : voxelized_envelope . csv ( low and high res ), svf points 1. Import Meshes 2. Import Lattice 3. Initialize vertical adjacency matrix Calculate distances 4. Construct the field Output : Distance to ground field ( low and high res ) Noise FLOWCHART UPDATEN Noise Noise Flowchart Noise Pseudo code 0. Noise field Noise_field.py Input : voxelized_envelope . csv ( low and high res ), noise source points , context mesh 1. Import Meshes 2. Import Lattice 3. For each noise source point : Assign a value corresponding with the amount of noise from that point For each voxel : Compute the distance to the noise source points Multiply the distance by the value of the noise source point Convert the values into values between 0 and 1 ( 0 = most noise , 1 = no noise ) 4. Construct the field Output : noise field ( low and high res ) Sun Accessibility Sun Accessibility Sun accessibility Sun Access Flowchart Sun Access Pseudo code 0. Sun access field Sun_access_field.py Input : voxelized_envelope . csv ( low and high res ), context mesh 1. Import Meshes 2. Import Lattice 3. Import Sun Vectors import Sunpath ( ladybug ) 4. Compute Intersection Create list of all vectors pointing towards the sun locations over the year For all voxels centers : o Compute rays towards all the sun points o If ray hits the context , skip that ray o Else store the ray Calculate the percentage of time each voxel sees the sun Convert the values into values between 0 and 1 ( 0 = no sun , 1 = much sun ) 5. Construct the field Output : sun access field ( low and high res ) Shadow Casting PSEUDO, FLOWCHART EN HIGHRES UPDATEN Shadow casting Shadow Casting Flowchart Shadow Casting Pseudo code 0. Shadow field Shadow_field.py Input : voxelized_envelope . csv ( low and high res ), context mesh 1. Import Meshes 2. Import Lattice 3. Import Sun Vectors import Sunpath ( ladybug ) ???? 4. Compute Intersection Create list of all vectors pointing towards the sun locations over the year For all voxels centers : o Compute rays towards all the sun points o If ray hits the context , skip that ray o Else store the ray Calculate the percentage of time each voxel sees the sun Convert the values into values between 0 and 1 ( 0 = no sun , 1 = much sun ) 5. Construct the field Output : shadow field ( low and high res ) Sky View Factor PSEUDO AFMAKEN Sky view factor View on Greenery Flowchart SVF Pseudo code 0. Sky view factor field Sky_view_factor_field.py Input : voxelized_envelope . csv ( low and high res ), context mesh 1. Import Meshes 2. Import Lattice SUNPATH ???? 3. Compute Intersection Create list of all vectors pointing towards the sun locations over the year For all voxels centers : o Compute rays towards all the sun points o If ray hits the context , skip that ray o Else store the ray Calculate the percentage of time each voxel sees the sun Convert the values into values between 0 and 1 ( 0 = no sun , 1 = much sun ) 4. Construct the field Output : sky view factor field ( low and high res ) View on Greenery TEST.... View on greenery View on Greenery Flowchart View on Green Pseudo code 0. View on Green field View_on_green_field.py Input : voxelized_envelope . csv ( low and high res ), green points , context mesh 1. Import Meshes 2. Import Lattice 3. Compute rays from green points to the center of the voxels For each ray the distance and intersection is calculated The outcome is reshaped Convert the values into values between 0 and 1 Construct the view on greenery field 4. Construct the field Output : view on greenery field ( low and high res )","title":"Product"},{"location":"Configuring/a2_configuring_product/#configuring-product","text":"","title":"Configuring: product"},{"location":"Configuring/a2_configuring_product/#high-res-fields-flowcharts-naar-proces-schematische-tekening","text":"","title":"HIGH RES FIELDS, Flowcharts naar proces + schematische tekening"},{"location":"Configuring/a2_configuring_product/#distance-to-main-entrance","text":"For creating a distance field based on walking through the building, we first created two different neigbourhood stencils to work with. The first stencil shows that going one voxel sideways (in x- or y-direction) the value of the neighbours will increment with 1. However, when someone wants to go a level up or down, this costs more energy than walking on the same level. Therefore, the neighbours in the z-direction will increment with the value of 2. Voxels PSEUDO CODE NAKIJKEN Distance to Main Entrance Flowchart Distance to Main Entrance Flowchart Distance to Main Entrance Pseudo code 0. Distance to main entrance field Distance_to_main_entrance_field.py Input : voxelized_envelope . csv ( low and high res ), points of main street and public transport 1. Import Meshes 2. Import Lattice 3. Compute from each voxel the average distance to the main street and public transport Choose the voxel with the minimum distance as the main entrance Retrieve the neighbour voxels of the main entrance Set the value of the horizontal neighbours to 1 and the vertical neighbours to 2 For each neighbour : Find the neighbours and add 1 ( horizontal ) or 2 ( vertical ) to it \u2019 s value , when it does not have a value yet Convert the values into values between 0 and 1 4. Construct the field Output : Distance to main entrance field ( low and high res )","title":"Distance to main entrance"},{"location":"Configuring/a2_configuring_product/#distance-to-the-ground","text":"PSEUDO CODE AANPASSEN Distance to Ground Distance to Ground Flowchart Distance to Ground Pseudo code 0. Distance to ground field Distance_to_ground_field.py Input : voxelized_envelope . csv ( low and high res ), svf points 1. Import Meshes 2. Import Lattice 3. Initialize vertical adjacency matrix Calculate distances 4. Construct the field Output : Distance to ground field ( low and high res )","title":"Distance to the ground"},{"location":"Configuring/a2_configuring_product/#noise","text":"FLOWCHART UPDATEN Noise Noise Flowchart Noise Pseudo code 0. Noise field Noise_field.py Input : voxelized_envelope . csv ( low and high res ), noise source points , context mesh 1. Import Meshes 2. Import Lattice 3. For each noise source point : Assign a value corresponding with the amount of noise from that point For each voxel : Compute the distance to the noise source points Multiply the distance by the value of the noise source point Convert the values into values between 0 and 1 ( 0 = most noise , 1 = no noise ) 4. Construct the field Output : noise field ( low and high res )","title":"Noise"},{"location":"Configuring/a2_configuring_product/#sun-accessibility","text":"Sun Accessibility Sun accessibility Sun Access Flowchart Sun Access Pseudo code 0. Sun access field Sun_access_field.py Input : voxelized_envelope . csv ( low and high res ), context mesh 1. Import Meshes 2. Import Lattice 3. Import Sun Vectors import Sunpath ( ladybug ) 4. Compute Intersection Create list of all vectors pointing towards the sun locations over the year For all voxels centers : o Compute rays towards all the sun points o If ray hits the context , skip that ray o Else store the ray Calculate the percentage of time each voxel sees the sun Convert the values into values between 0 and 1 ( 0 = no sun , 1 = much sun ) 5. Construct the field Output : sun access field ( low and high res )","title":"Sun Accessibility"},{"location":"Configuring/a2_configuring_product/#shadow-casting","text":"PSEUDO, FLOWCHART EN HIGHRES UPDATEN Shadow casting Shadow Casting Flowchart Shadow Casting Pseudo code 0. Shadow field Shadow_field.py Input : voxelized_envelope . csv ( low and high res ), context mesh 1. Import Meshes 2. Import Lattice 3. Import Sun Vectors import Sunpath ( ladybug ) ???? 4. Compute Intersection Create list of all vectors pointing towards the sun locations over the year For all voxels centers : o Compute rays towards all the sun points o If ray hits the context , skip that ray o Else store the ray Calculate the percentage of time each voxel sees the sun Convert the values into values between 0 and 1 ( 0 = no sun , 1 = much sun ) 5. Construct the field Output : shadow field ( low and high res )","title":"Shadow Casting"},{"location":"Configuring/a2_configuring_product/#sky-view-factor","text":"PSEUDO AFMAKEN Sky view factor View on Greenery Flowchart SVF Pseudo code 0. Sky view factor field Sky_view_factor_field.py Input : voxelized_envelope . csv ( low and high res ), context mesh 1. Import Meshes 2. Import Lattice SUNPATH ???? 3. Compute Intersection Create list of all vectors pointing towards the sun locations over the year For all voxels centers : o Compute rays towards all the sun points o If ray hits the context , skip that ray o Else store the ray Calculate the percentage of time each voxel sees the sun Convert the values into values between 0 and 1 ( 0 = no sun , 1 = much sun ) 4. Construct the field Output : sky view factor field ( low and high res )","title":"Sky View Factor"},{"location":"Configuring/a2_configuring_product/#view-on-greenery","text":"TEST.... View on greenery View on Greenery Flowchart View on Green Pseudo code 0. View on Green field View_on_green_field.py Input : voxelized_envelope . csv ( low and high res ), green points , context mesh 1. Import Meshes 2. Import Lattice 3. Compute rays from green points to the center of the voxels For each ray the distance and intersection is calculated The outcome is reshaped Convert the values into values between 0 and 1 Construct the view on greenery field 4. Construct the field Output : view on greenery field ( low and high res )","title":"View on Greenery"},{"location":"Final_Deliveries/bibliography/","text":"Bibliography Here you should cite all references and materials that you have used in your project. This is in addition to citation in the documentation itself.","title":"Bibliography"},{"location":"Final_Deliveries/bibliography/#bibliography","text":"Here you should cite all references and materials that you have used in your project. This is in addition to citation in the documentation itself.","title":"Bibliography"},{"location":"Final_Deliveries/figures/","text":"Figures Here you should include all of your figures and links to the pages that they have been used in. You can embed your only videos like this:","title":"Figures"},{"location":"Final_Deliveries/figures/#figures","text":"Here you should include all of your figures and links to the pages that they have been used in. You can embed your only videos like this:","title":"Figures"},{"location":"Final_Deliveries/presentations/","text":"Presentations Here you should embed your poster and presentations. Here is an example:","title":"Presentations"},{"location":"Final_Deliveries/presentations/#presentations","text":"Here you should embed your poster and presentations. Here is an example:","title":"Presentations"},{"location":"Final_Deliveries/scripts/","text":"Scripts Kopjes invoegen per cell Here you should include all of your scripts whether they are text, python notebook or procedural scripts. You should also include link to the link to relevant location in the main pages, description, explanatory materials such as pseudo code or flowcharts, and visualizations if it is applicable. If necessary this page can be broken down to multiple pages. Here is an example of how to include your scripts: Import Dynamic_fields.ipynb 1 2 3 4 5 6 7 import os import topogenesis as tg import pyvista as pv import trimesh as tm import pandas as pd import numpy as np import copy 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def distance_field ( occ_lattice , env_lattice , a_id ): # creating neighborhood definition 1 stencil = tg . create_stencil ( \"von_neumann\" , 1 , 1 ) # setting the indices stencil . set_index ([ 0 , 0 , 0 ], 0 ) occ_array_padded = np . pad ( occ_lattice , 1 , mode = \"constant\" , constant_values =- 1 ) env_array_padded = np . pad ( env_lattice , 1 , mode = \"constant\" , constant_values = False ) padded_minbound = env_lattice . minbound - env_lattice . unit env_lattice_padded = tg . to_lattice ( env_array_padded , minbound = padded_minbound , unit = env_lattice . unit ) occ_lattice_padded = tg . to_lattice ( occ_array_padded , minbound = padded_minbound , unit = env_lattice . unit ) distance_lattice = env_lattice_padded * False a_voexls_3d_ind_padded = tuple ( np . argwhere ( occ_lattice_padded == a_id ) . T + 1 ) # print(a_voexls_3d_ind_padded) distance_lattice [ a_voexls_3d_ind_padded ] = True # retrieve the neighbour list of each cell neighs = distance_lattice . find_neighbours ( stencil ) # set the maximum distance to sum of the size of the lattice in all dimensions. max_dist = np . sum ( distance_lattice . shape ) # initialize the street network distance lattice with all the street cells as 0, and all other cells as maximum distance possible mn_dist_lattice = 1 - distance_lattice mn_dist_lattice [ mn_dist_lattice == 1 ] = max_dist # flatten the distance lattice for easy access mn_dist_lattice_flat = mn_dist_lattice . flatten () # flatten the envelope lattice env_pad_lat_flat = env_lattice_padded . flatten () # main loop for breath-first traversal for i in range ( 1 , max_dist ): # find the neighbours of the previous step next_step = neighs [ mn_dist_lattice_flat == i - 1 ] # find the unique neighbours next_unq_step = np . unique ( next_step . flatten ()) # check if the neighbours of the next step are inside the envelope validity_condition = env_pad_lat_flat [ next_unq_step ] # select the valid neighbours next_valid_step = next_unq_step [ validity_condition ] # make a copy of the lattice to prevent overwriting in the memory mn_nex_dist_lattice_flat = np . copy ( mn_dist_lattice_flat ) # set the next step cells to the current distance mn_nex_dist_lattice_flat [ next_valid_step ] = i # find the minimum of the current distance and previous distances to avoid overwriting previous steps mn_dist_lattice_flat = np . minimum ( mn_dist_lattice_flat , mn_nex_dist_lattice_flat ) # check how many of the cells have not been traversed yet filled_check = mn_dist_lattice_flat * env_pad_lat_flat == max_dist # if all the cells have been traversed, break the loop if filled_check . sum () == 0 : # print(i) break # reshape and construct a lattice from the street network distance list mn_dist_lattice = mn_dist_lattice_flat . reshape ( mn_dist_lattice . shape ) mn_dist_lattice = mn_dist_lattice . astype ( float ) mn_dist_lattice *= env_lattice_padded mn_dist_lattice = env_lattice_padded - ( mn_dist_lattice - mn_dist_lattice . min ()) / mn_dist_lattice . max () return mn_dist_lattice","title":"Scripts"},{"location":"Final_Deliveries/scripts/#scripts","text":"","title":"Scripts"},{"location":"Final_Deliveries/scripts/#kopjes-invoegen-per-cell","text":"Here you should include all of your scripts whether they are text, python notebook or procedural scripts. You should also include link to the link to relevant location in the main pages, description, explanatory materials such as pseudo code or flowcharts, and visualizations if it is applicable. If necessary this page can be broken down to multiple pages. Here is an example of how to include your scripts: Import Dynamic_fields.ipynb 1 2 3 4 5 6 7 import os import topogenesis as tg import pyvista as pv import trimesh as tm import pandas as pd import numpy as np import copy 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def distance_field ( occ_lattice , env_lattice , a_id ): # creating neighborhood definition 1 stencil = tg . create_stencil ( \"von_neumann\" , 1 , 1 ) # setting the indices stencil . set_index ([ 0 , 0 , 0 ], 0 ) occ_array_padded = np . pad ( occ_lattice , 1 , mode = \"constant\" , constant_values =- 1 ) env_array_padded = np . pad ( env_lattice , 1 , mode = \"constant\" , constant_values = False ) padded_minbound = env_lattice . minbound - env_lattice . unit env_lattice_padded = tg . to_lattice ( env_array_padded , minbound = padded_minbound , unit = env_lattice . unit ) occ_lattice_padded = tg . to_lattice ( occ_array_padded , minbound = padded_minbound , unit = env_lattice . unit ) distance_lattice = env_lattice_padded * False a_voexls_3d_ind_padded = tuple ( np . argwhere ( occ_lattice_padded == a_id ) . T + 1 ) # print(a_voexls_3d_ind_padded) distance_lattice [ a_voexls_3d_ind_padded ] = True # retrieve the neighbour list of each cell neighs = distance_lattice . find_neighbours ( stencil ) # set the maximum distance to sum of the size of the lattice in all dimensions. max_dist = np . sum ( distance_lattice . shape ) # initialize the street network distance lattice with all the street cells as 0, and all other cells as maximum distance possible mn_dist_lattice = 1 - distance_lattice mn_dist_lattice [ mn_dist_lattice == 1 ] = max_dist # flatten the distance lattice for easy access mn_dist_lattice_flat = mn_dist_lattice . flatten () # flatten the envelope lattice env_pad_lat_flat = env_lattice_padded . flatten () # main loop for breath-first traversal for i in range ( 1 , max_dist ): # find the neighbours of the previous step next_step = neighs [ mn_dist_lattice_flat == i - 1 ] # find the unique neighbours next_unq_step = np . unique ( next_step . flatten ()) # check if the neighbours of the next step are inside the envelope validity_condition = env_pad_lat_flat [ next_unq_step ] # select the valid neighbours next_valid_step = next_unq_step [ validity_condition ] # make a copy of the lattice to prevent overwriting in the memory mn_nex_dist_lattice_flat = np . copy ( mn_dist_lattice_flat ) # set the next step cells to the current distance mn_nex_dist_lattice_flat [ next_valid_step ] = i # find the minimum of the current distance and previous distances to avoid overwriting previous steps mn_dist_lattice_flat = np . minimum ( mn_dist_lattice_flat , mn_nex_dist_lattice_flat ) # check how many of the cells have not been traversed yet filled_check = mn_dist_lattice_flat * env_pad_lat_flat == max_dist # if all the cells have been traversed, break the loop if filled_check . sum () == 0 : # print(i) break # reshape and construct a lattice from the street network distance list mn_dist_lattice = mn_dist_lattice_flat . reshape ( mn_dist_lattice . shape ) mn_dist_lattice = mn_dist_lattice . astype ( float ) mn_dist_lattice *= env_lattice_padded mn_dist_lattice = env_lattice_padded - ( mn_dist_lattice - mn_dist_lattice . min ()) / mn_dist_lattice . max () return mn_dist_lattice","title":"Kopjes invoegen per cell"},{"location":"Forming/a4_forming_process/","text":"Forming: process Here you should include the process and product of your 4th activity: Forming Title Forming (process): Form (product) Objective Document the process and products and provide explanations to ensure reusability of materials. Procedure Finalize the plans and the forms of all functional units. Optionally, choose a way to alter the jaggedness of voxels in the final form by partially bringing in contrasting curvy shapes, for instance as a shell around the building, e.g. through smoothing, relaxation, iso-surfaces, or topological transformation. ARCH check spelling en layouts Flowchart architectural floor plan generator TEST.... Decision Tree Floorplan Generator Floor plan TEST.... Floor plan living, laundry, bedroom and private toilet Floor plan TEST.... Floor plan with hidden corridors of living, laundry, bedroom and private toilet Floor plan TEST.... Floor plan library, shops, kitchen and gym Floor plan TEST.... Floor plan with hidden corridors of library, shops, kitchen and gym Floor plan TEST.... Floor plan restaurant, public toilet and workspaces Floor plan TEST.... Floor plan with hidden corridors of restaurant, public toilet and workspaces Catalogue TEST.... Catalogue Below is a roadmap, designed for making a floor plan for any given space. It makes the plan based on the area given, this then gets converted into an amount of mini- and microvoxels. Then the furniture gets selected that is assigned to the type of space. After that the borders of the furniture are assigned. Neighbours are assigned. Assemble the floor plan, make sure there are no double hidden corridors to not waste space. Make the plan orthogonal. And finally evaluate the plan, does it work? Catalogue game in steps (Living Room) Catalogue game in steps (Kitchen) Catalogue game in steps (Caf\u00e9) Pseudo code 0. Import TEST.py 1 2 3 4 5 import os import topogenesis as tg import pyvista as pv import trimesh as tm import numpy as np 1. TEST TEST.py 1 hello world","title":"Process"},{"location":"Forming/a4_forming_process/#forming-process","text":"Here you should include the process and product of your 4th activity: Forming Title Forming (process): Form (product) Objective Document the process and products and provide explanations to ensure reusability of materials. Procedure Finalize the plans and the forms of all functional units. Optionally, choose a way to alter the jaggedness of voxels in the final form by partially bringing in contrasting curvy shapes, for instance as a shell around the building, e.g. through smoothing, relaxation, iso-surfaces, or topological transformation.","title":"Forming: process"},{"location":"Forming/a4_forming_process/#arch-check-spelling-en-layouts","text":"","title":"ARCH check spelling en layouts"},{"location":"Forming/a4_forming_process/#flowchart-architectural-floor-plan-generator","text":"TEST.... Decision Tree Floorplan Generator","title":"Flowchart architectural floor plan generator"},{"location":"Forming/a4_forming_process/#floor-plan","text":"TEST.... Floor plan living, laundry, bedroom and private toilet","title":"Floor plan"},{"location":"Forming/a4_forming_process/#floor-plan_1","text":"TEST.... Floor plan with hidden corridors of living, laundry, bedroom and private toilet","title":"Floor plan"},{"location":"Forming/a4_forming_process/#floor-plan_2","text":"TEST.... Floor plan library, shops, kitchen and gym","title":"Floor plan"},{"location":"Forming/a4_forming_process/#floor-plan_3","text":"TEST.... Floor plan with hidden corridors of library, shops, kitchen and gym","title":"Floor plan"},{"location":"Forming/a4_forming_process/#floor-plan_4","text":"TEST.... Floor plan restaurant, public toilet and workspaces","title":"Floor plan"},{"location":"Forming/a4_forming_process/#floor-plan_5","text":"TEST.... Floor plan with hidden corridors of restaurant, public toilet and workspaces","title":"Floor plan"},{"location":"Forming/a4_forming_process/#catalogue","text":"TEST....","title":"Catalogue"},{"location":"Forming/a4_forming_process/#catalogue_1","text":"Below is a roadmap, designed for making a floor plan for any given space. It makes the plan based on the area given, this then gets converted into an amount of mini- and microvoxels. Then the furniture gets selected that is assigned to the type of space. After that the borders of the furniture are assigned. Neighbours are assigned. Assemble the floor plan, make sure there are no double hidden corridors to not waste space. Make the plan orthogonal. And finally evaluate the plan, does it work? Catalogue game in steps (Living Room) Catalogue game in steps (Kitchen) Catalogue game in steps (Caf\u00e9)","title":"Catalogue"},{"location":"Forming/a4_forming_process/#pseudo-code","text":"","title":"Pseudo code"},{"location":"Forming/a4_forming_process/#0-import","text":"TEST.py 1 2 3 4 5 import os import topogenesis as tg import pyvista as pv import trimesh as tm import numpy as np","title":"0. Import"},{"location":"Forming/a4_forming_process/#1-test","text":"TEST.py 1 hello world","title":"1. TEST"},{"location":"Forming/a4_forming_product/","text":"Forming: product RENDER Gif of the massing","title":"Product"},{"location":"Forming/a4_forming_product/#forming-product","text":"","title":"Forming: product"},{"location":"Forming/a4_forming_product/#render","text":"Gif of the massing","title":"RENDER"},{"location":"Massing/a3_massing_process/","text":"Massing: process Flowcharts van product + zoom, schem. tek. Seed allocation/initialization Explanation of allocation/initialization Initialization of the agents Pseudo code Initialization_agents.py 1 2 3 4 5 6 7 8 9 10 11 Input : voxelized_envelope . csv ( high res ), fields , program of requirement Initialize the empty occupation lattice ( full of - 1 ) For the agent ids and the agent preferences : Create a preference lattice for every agent Raise the value of every field by the weight given in the program Select the voxel with the highest value Move the voxel to ground level , to prevent floating parts Change the value in the occupation and availability lattice Output : Initialized agents Evaluate voxel Pseudo code Evaluate_voxels.py 1 2 3 4 5 6 7 8 9 10 Input : location of the to be evaluated voxels , fields , preferences Create a list full of ones with the same length as the amount of voxels to be evaluated For each agent : Find the raw value of these voxels in the fields Raise these values with the weight of each preference Multiply all the new values with each other to get the final value Return the final values Output : new values of evaluated voxels Change value Beneath is the pseudo code for the change values code. When the agent has grown to its max amount of voxels, the value of the neighbours will be compared with the value of its own voxels. When the neighbour has a value which is 10% higher, it will be occupied and the other voxel will be removed. Pseudo code Change_value.py 1 2 3 4 5 6 7 8 9 10 11 Input : occupation lattice , availability lattice , location , agent location list , new id If the voxel needs to get occupied ( new id > - 1 in occupation lattice ): Add the location to the list of agent locations Change the value of the availability lattice to occupied ( = 0 ) Else ( voxel needs to be removed ): Remove the location from the agent locations list Change the value of the availability lattice to unoccupied ( = 1 ) Change the value of the occupation lattice to the new id Output : new occupation lattice , new availability lattice , location , agents location list Update availlability lattice Pseudo code Update_voxels.py 1 2 3 4 5 6 7 8 9 Input : occupation lattice Retrieve the location of the occupied voxels ( id > - 1 ) Move the occupied voxels one place up Subtract the new occupation lattice from the old occupation lattice Now only the voxels with voxels beneath are available ( id = 1 in avail_lattice ) Set the voxels on ground level which have now the value 0 ( unoccupied ) to 1 so the agent can grow to the sides as well . Output : new availability lattice Building depth Pseudo code Building_depth.py 1 2 3 4 5 6 7 8 Input : occupation lattice , availability lattice , max . building depth Create stencils to check the different directions Create conditions for each direction In the x - direction there can \u2019 t be more voxels next to each other than the max building depth In the y - direction there can \u2019 t be more voxels next to each other than the max building depth Output : new availability lattice Before choosing a final mass there were four options as we had 2 functions to choose out off. Below are the results of both functions off, float function off, both functions on and finally the final mass that has only the float function on. Mass variant, both functions off Mass variant, float function off Mass variant, both functions on Final mass Centers of clusters Pseudo code Cluster_centers.py 1 2 3 4 5 6 Input : massing lattice Find the different clusters in the grown ABM Choose which voxel fits the best as centre of the agent cluster Output : cluster centers Shafts Pseudo code Shaft_forming.py 1 2 3 4 5 6 Input : cluster centers Create 4 clusters from the chosen cluster centres Choose which row of voxels fits the best as centre of the clusters Output : shafts Paths Pseudo code Corridor_forming.py 1 2 3 4 5 6 7 8 Input : shafts , main entrance For every cluster center Find the shortest path to a shaft For every shaft Find the shortest path to the main entrance Output : corridors An example of the growth of the fields, shown below is the student house. Student house growth","title":"Process"},{"location":"Massing/a3_massing_process/#massing-process","text":"","title":"Massing: process"},{"location":"Massing/a3_massing_process/#flowcharts-van-product-zoom-schem-tek","text":"","title":"Flowcharts van product + zoom, schem. tek."},{"location":"Massing/a3_massing_process/#seed-allocationinitialization","text":"Explanation of allocation/initialization Initialization of the agents Pseudo code Initialization_agents.py 1 2 3 4 5 6 7 8 9 10 11 Input : voxelized_envelope . csv ( high res ), fields , program of requirement Initialize the empty occupation lattice ( full of - 1 ) For the agent ids and the agent preferences : Create a preference lattice for every agent Raise the value of every field by the weight given in the program Select the voxel with the highest value Move the voxel to ground level , to prevent floating parts Change the value in the occupation and availability lattice Output : Initialized agents Evaluate voxel Pseudo code Evaluate_voxels.py 1 2 3 4 5 6 7 8 9 10 Input : location of the to be evaluated voxels , fields , preferences Create a list full of ones with the same length as the amount of voxels to be evaluated For each agent : Find the raw value of these voxels in the fields Raise these values with the weight of each preference Multiply all the new values with each other to get the final value Return the final values Output : new values of evaluated voxels Change value Beneath is the pseudo code for the change values code. When the agent has grown to its max amount of voxels, the value of the neighbours will be compared with the value of its own voxels. When the neighbour has a value which is 10% higher, it will be occupied and the other voxel will be removed. Pseudo code Change_value.py 1 2 3 4 5 6 7 8 9 10 11 Input : occupation lattice , availability lattice , location , agent location list , new id If the voxel needs to get occupied ( new id > - 1 in occupation lattice ): Add the location to the list of agent locations Change the value of the availability lattice to occupied ( = 0 ) Else ( voxel needs to be removed ): Remove the location from the agent locations list Change the value of the availability lattice to unoccupied ( = 1 ) Change the value of the occupation lattice to the new id Output : new occupation lattice , new availability lattice , location , agents location list Update availlability lattice Pseudo code Update_voxels.py 1 2 3 4 5 6 7 8 9 Input : occupation lattice Retrieve the location of the occupied voxels ( id > - 1 ) Move the occupied voxels one place up Subtract the new occupation lattice from the old occupation lattice Now only the voxels with voxels beneath are available ( id = 1 in avail_lattice ) Set the voxels on ground level which have now the value 0 ( unoccupied ) to 1 so the agent can grow to the sides as well . Output : new availability lattice Building depth Pseudo code Building_depth.py 1 2 3 4 5 6 7 8 Input : occupation lattice , availability lattice , max . building depth Create stencils to check the different directions Create conditions for each direction In the x - direction there can \u2019 t be more voxels next to each other than the max building depth In the y - direction there can \u2019 t be more voxels next to each other than the max building depth Output : new availability lattice Before choosing a final mass there were four options as we had 2 functions to choose out off. Below are the results of both functions off, float function off, both functions on and finally the final mass that has only the float function on. Mass variant, both functions off Mass variant, float function off Mass variant, both functions on Final mass Centers of clusters Pseudo code Cluster_centers.py 1 2 3 4 5 6 Input : massing lattice Find the different clusters in the grown ABM Choose which voxel fits the best as centre of the agent cluster Output : cluster centers Shafts Pseudo code Shaft_forming.py 1 2 3 4 5 6 Input : cluster centers Create 4 clusters from the chosen cluster centres Choose which row of voxels fits the best as centre of the clusters Output : shafts Paths Pseudo code Corridor_forming.py 1 2 3 4 5 6 7 8 Input : shafts , main entrance For every cluster center Find the shortest path to a shaft For every shaft Find the shortest path to the main entrance Output : corridors An example of the growth of the fields, shown below is the student house. Student house growth","title":"Seed allocation/initialization"},{"location":"Massing/a3_massing_product/","text":"Massing: product MOET ALLEMAAL WEG // UITKOMST MASS + GIF + IMGS Gif of the massing Final mass Legend 1 Legend 2 Legend 3 Floor plan gif Top view of the building in context with the city","title":"Product"},{"location":"Massing/a3_massing_product/#massing-product","text":"","title":"Massing: product"},{"location":"Massing/a3_massing_product/#moet-allemaal-weg-uitkomst-mass-gif-imgs","text":"Gif of the massing Final mass Legend 1 Legend 2 Legend 3 Floor plan gif Top view of the building in context with the city","title":"MOET ALLEMAAL WEG // UITKOMST MASS + GIF + IMGS"},{"location":"Planning/a1_planning_process/","text":"Planning: process Here you should include the process and product of your 1st activity: Planning Title Planning (process): Programme of Requirements & Network (product) Objective Formulate the design problems, form a programme of requirements, form a network, formulate your design principles and the idea (spatial sequences/experience/stories visible in a network). Procedure Describe the hierarchy of design decisions, formulate design goals, define design principles, identify stages in the design process that could be supported by algorithms, draw a flowchart to reflect on these steps and their connections and update it every week. Develop a programme of requirements, an idea (encapsulating the added value of the building and what is going to be unique about it in terms of human experiences) and a corresponding network indicating the main trips inside the building to be facilitated by direct connections matching with the scenarios envisaged in the idea. Formulate the design principles indicating what is a good shape for the building given operational, climatic, or structural aspects. PvE finaliseren, afbeeldingen invoegen, relations chart naar product + ANALYSE? Design goals Using the existing surrounding structures and creating a new function/environment. (train) Next to the site there is an unused train track. The train track is currently used by restaurants and caf\u00e9s. The train track provides a unique and creative location and is attractive to business owners and new developers. Especially since it's close to the city centre, the location provides a lot of potential. Integrating surrounding wall paintings on the site The area around the site has a lot of different wall paintings. This is something characteristic of Rotterdam, and especially Rotterdam-north. An improvement on the side would be integrating these artistic pieces on the building site and the surrounding area. Keeping current existing businesses onto the site and in the building Currently the building is used by various: restaurants, businesses and foundations. The idea is to keep these businesses on the newly developed site. and integrate them into the new program Expanding and connecting surrounding green structures to create qualitative greenery The area is currently divided into different sections of greenery. The disconnection between the green structures creates a low quality of green. by connecting and expanding the greenery, a more qualitative feel is created. Creating an accessible connection between the building and the surrounding area. By making entrances facing general accessibility points or entrance areas the site becomes more open towards the public Design principles 1. Creating a good living condition which includes: enough daylight in every space reduce sound pollution view on green spaces (certain percentage) Public spaces are separated from the private and communal spaces, (in which the public functions are easily accessible form public routes) Seperate public and private spaces Modules or components can be combined in a flexible way across a system standardized grid size Modularity Program of Requirements In the table below the requirements for every type of space is defined. The amount of housing is set from the start. The table shows the type of space, size in m\u00b2, size per unit (for housing) and the amount of voxels. Routing We created different routings for the different target groups of the building; students, starters, elderly and visitors. The first 3 groups have a division in arriving to their homes (external routing) and the routes they take inside the building (internal routing). The routing diagrams also include the approximate times of occurrence per week. This will help weight each connection between the spaces. Students External Internal Starters External Internal Elderly External Internal Visitors","title":"Process"},{"location":"Planning/a1_planning_process/#planning-process","text":"Here you should include the process and product of your 1st activity: Planning Title Planning (process): Programme of Requirements & Network (product) Objective Formulate the design problems, form a programme of requirements, form a network, formulate your design principles and the idea (spatial sequences/experience/stories visible in a network). Procedure Describe the hierarchy of design decisions, formulate design goals, define design principles, identify stages in the design process that could be supported by algorithms, draw a flowchart to reflect on these steps and their connections and update it every week. Develop a programme of requirements, an idea (encapsulating the added value of the building and what is going to be unique about it in terms of human experiences) and a corresponding network indicating the main trips inside the building to be facilitated by direct connections matching with the scenarios envisaged in the idea. Formulate the design principles indicating what is a good shape for the building given operational, climatic, or structural aspects.","title":"Planning: process"},{"location":"Planning/a1_planning_process/#pve-finaliseren-afbeeldingen-invoegen-relations-chart-naar-product-analyse","text":"","title":"PvE finaliseren, afbeeldingen invoegen, relations chart naar product + ANALYSE?"},{"location":"Planning/a1_planning_process/#design-goals","text":"Using the existing surrounding structures and creating a new function/environment. (train) Next to the site there is an unused train track. The train track is currently used by restaurants and caf\u00e9s. The train track provides a unique and creative location and is attractive to business owners and new developers. Especially since it's close to the city centre, the location provides a lot of potential. Integrating surrounding wall paintings on the site The area around the site has a lot of different wall paintings. This is something characteristic of Rotterdam, and especially Rotterdam-north. An improvement on the side would be integrating these artistic pieces on the building site and the surrounding area. Keeping current existing businesses onto the site and in the building Currently the building is used by various: restaurants, businesses and foundations. The idea is to keep these businesses on the newly developed site. and integrate them into the new program Expanding and connecting surrounding green structures to create qualitative greenery The area is currently divided into different sections of greenery. The disconnection between the green structures creates a low quality of green. by connecting and expanding the greenery, a more qualitative feel is created. Creating an accessible connection between the building and the surrounding area. By making entrances facing general accessibility points or entrance areas the site becomes more open towards the public","title":"Design goals"},{"location":"Planning/a1_planning_process/#design-principles","text":"1. Creating a good living condition which includes: enough daylight in every space reduce sound pollution view on green spaces (certain percentage) Public spaces are separated from the private and communal spaces, (in which the public functions are easily accessible form public routes) Seperate public and private spaces Modules or components can be combined in a flexible way across a system standardized grid size Modularity","title":"Design principles"},{"location":"Planning/a1_planning_process/#program-of-requirements","text":"In the table below the requirements for every type of space is defined. The amount of housing is set from the start. The table shows the type of space, size in m\u00b2, size per unit (for housing) and the amount of voxels.","title":"Program of Requirements"},{"location":"Planning/a1_planning_process/#routing","text":"We created different routings for the different target groups of the building; students, starters, elderly and visitors. The first 3 groups have a division in arriving to their homes (external routing) and the routes they take inside the building (internal routing). The routing diagrams also include the approximate times of occurrence per week. This will help weight each connection between the spaces.","title":"Routing"},{"location":"Planning/a1_planning_process/#students","text":"External Internal","title":"Students"},{"location":"Planning/a1_planning_process/#starters","text":"External Internal","title":"Starters"},{"location":"Planning/a1_planning_process/#elderly","text":"External Internal","title":"Elderly"},{"location":"Planning/a1_planning_process/#visitors","text":"","title":"Visitors"},{"location":"Planning/a1_planning_product/","text":"Planning: product ADJACENCY EN WEIGHTED (Relations) Metro diagram The first objective of the design was to create a network graph visualizing the main trips inside the building based on our design goals: Adjacency matrix Relations between spaces, being either 0 or 1, thus defining if there is a connection between spaces or not. Relations between spaces Relations between spaces, ranging from 0-1. This defines how strong the pull between certain spaces is.","title":"Product"},{"location":"Planning/a1_planning_product/#planning-product","text":"","title":"Planning: product"},{"location":"Planning/a1_planning_product/#adjacency-en-weighted-relations","text":"","title":"ADJACENCY EN WEIGHTED (Relations)"},{"location":"Planning/a1_planning_product/#metro-diagram","text":"The first objective of the design was to create a network graph visualizing the main trips inside the building based on our design goals:","title":"Metro diagram"},{"location":"Planning/a1_planning_product/#adjacency-matrix","text":"Relations between spaces, being either 0 or 1, thus defining if there is a connection between spaces or not.","title":"Adjacency matrix"},{"location":"Planning/a1_planning_product/#relations-between-spaces","text":"Relations between spaces, ranging from 0-1. This defines how strong the pull between certain spaces is.","title":"Relations between spaces"},{"location":"Scripts/distance_entrance/","text":"Distance entrance Import packages 1 2 3 4 5 6 7 8 import os import topogenesis as tg import pyvista as pv import trimesh as tm import numpy as np import networkx as nx from scipy.interpolate import RegularGridInterpolator import resources.functions as f Import meshes 1 2 3 4 5 6 envelope_path = os . path . relpath ( '../data/new_envelope.obj' ) context_path = os . path . relpath ( '../data/immediate_context.obj' ) # load the mesh from file envelope_mesh = tm . load ( envelope_path ) context_mesh = tm . load ( context_path ) Import envelope lattice 1 2 3 4 5 6 7 8 9 10 11 # loading the lowres lattice from csv field_path = os . path . relpath ( \"../data/envelope_lowres.csv\" ) envelope_lattice = tg . lattice_from_csv ( field_path ) init_avail_lattice = tg . to_lattice ( np . copy ( envelope_lattice ), envelope_lattice ) # create a full lattice full with ones full_lattice = envelope_lattice * 0 + 1 # loading the highres lattice from csv field_path = os . path . relpath ( \"../data/envelope_highres.csv\" ) highres_lattice = tg . lattice_from_csv ( field_path ) Import street points + public transport points 1 2 street_transport_path = os . path . relpath ( '../data/mainstreet_publictransport.xyz.txt' ) street_transport = np . genfromtxt ( street_transport_path , delimiter = ',' ) Euclidean distance lattice Distance matrix 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # extracting the centroid of all voxels env_cens = envelope_lattice . centroids_threshold ( - 1 ) # initializing the distance matrix dist_m = [] # for each voxel ... for voxel_cen in env_cens : # initializing the distance vector (per each voxel) dist_v = [] # for each street point ... for street_transport_point in street_transport : # find the difference vector diff = voxel_cen - street_transport_point # raise the components to the power of two diff_p2 = diff ** 2 # sum the components diff_p2s = diff_p2 . sum () # compute the square root dist = diff_p2s ** 0.5 # add the distance to the distance vector dist_v . append ( dist ) # add the distance vector to the distance matrix dist_m . append ( dist_v ) # change the distance matrix type, from list to array dist_m = np . array ( dist_m ) Selecting entrance voxel Finding min distance to street and public 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # average of the distances to each point per voxel av_dist = [] for str_trans_points in dist_m : # calculate av_dist by taking the sum of the distances and divide by the amount of street points av_dist_vox = str_trans_points . sum () / len ( street_transport ) av_dist . append ( av_dist_vox ) # Find the voxel with the minimum average distance min_dist = np . min ( av_dist ) # Find the index of this voxel min_index = np . argmin ( av_dist ) # get the 3d location min_index_3d = np . unravel_index ( min_index , envelope_lattice . shape ) Import the stencils Stencil horizontal 1 2 3 4 5 6 7 8 # creating neighborhood definition 1 (horizontal) stencil_1 = tg . create_stencil ( \"von_neumann\" , 0 , 1 ) # setting the indices stencil_1 . set_index ([ 0 , 0 , 0 ], 0 ) stencil_1 . set_index ([ 0 , - 1 , 0 ], 1 ) stencil_1 . set_index ([ 0 , 1 , 0 ], 1 ) stencil_1 . set_index ([ - 1 , 0 , 0 ], 1 ) stencil_1 . set_index ([ 1 , 0 , 0 ], 1 ) Stencil vertical 1 2 3 4 5 6 # creating neighborhood definition 2 (vertical) stencil_2 = tg . create_stencil ( \"von_neumann\" , 0 , 1 ) # setting the indices stencil_2 . set_index ([ 0 , 0 , 0 ], 0 ) stencil_2 . set_index ([ 0 , 0 , - 1 ], 1 ) stencil_2 . set_index ([ 0 , 0 , 1 ], 1 ) Make envelope padded 1 2 3 4 5 6 7 8 9 # make envelope padded to prevent seeing one side as a neighbour of the other side env_padded_array = np . pad ( envelope_lattice , 1 ) padded_minbound = envelope_lattice . minbound - envelope_lattice . unit env_padded_lattice = tg . to_lattice ( env_padded_array , minbound = padded_minbound , unit = envelope_lattice . unit ) # convert the location of the main entrance to the right envelope str_con_lattice = env_padded_lattice * False ent_sel_3d_ind_padded = tuple ( np . array ( np . unravel_index ( min_index , envelope_lattice . shape )) + 1 ) str_con_lattice [ ent_sel_3d_ind_padded ] = True Distance lattice Retrieve neighbours 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # retrieve the neighbour list of each cell neighs_1 = str_con_lattice . find_neighbours ( stencil_1 ) neighs_2 = str_con_lattice . find_neighbours ( stencil_2 ) # set the maximum distance to sum of the size of the lattice in all dimensions. max_dist = np . sum ( str_con_lattice . shape ) # initialize the street network distance lattice with all the street cells as 0, and all other cells as maximum distance possible mn_dist_lattice = 1 - str_con_lattice mn_dist_lattice [ mn_dist_lattice == 1 ] = max_dist # flatten the distance lattice for easy access mn_dist_lattice_flat = mn_dist_lattice . flatten () # flatten the envelope lattice env_pad_lat_flat = env_padded_lattice . flatten () Giving every voxel values 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 # main loop for breath-first traversal for i in range ( 1 , max_dist ): # find the neighbours of the previous step next_step_1 = neighs_1 [ mn_dist_lattice_flat == i - 1 ] # find the unique neighbours next_unq_step_1 = np . unique ( next_step_1 . flatten ()) # check if the neighbours of the next step are inside the envelope validity_condition_1 = env_pad_lat_flat [ next_unq_step_1 ] # select the valid neighbours next_valid_step_1 = next_unq_step_1 [ validity_condition_1 ] # find the neighbours of the previous step next_step_2 = neighs_2 [ mn_dist_lattice_flat == i - 1 ] # find the unique neighbours next_unq_step_2 = np . unique ( next_step_2 . flatten ()) # check if the neighbours of the next step are inside the envelope validity_condition_2 = env_pad_lat_flat [ next_unq_step_2 ] # select the valid neighbours next_valid_step_2 = next_unq_step_2 [ validity_condition_2 ] # make a copy of the lattice to prevent overwriting in the memory mn_nex_dist_lattice_flat = np . copy ( mn_dist_lattice_flat ) # set the next step cells to the current distance mn_nex_dist_lattice_flat [ next_valid_step_2 ] = i + 1 # set the next step cells to the current distance mn_nex_dist_lattice_flat [ next_valid_step_1 ] = i # find the minimum of the current distance and previous distances to avoid overwriting previous steps mn_dist_lattice_flat = np . minimum ( mn_dist_lattice_flat , mn_nex_dist_lattice_flat ) # check how many of the cells have not been traversed yet filled_check = mn_dist_lattice_flat * env_pad_lat_flat == max_dist # if all the cells have been traversed, break the loop if filled_check . sum () == 0 : print ( i ) break # reshape and construct a lattice from the street network distance list mn_dist_lattice = mn_dist_lattice_flat . reshape ( mn_dist_lattice . shape ) mn_dist_lattice = mn_dist_lattice . astype ( float ) mn_dist_lattice *= env_padded_lattice # reverse the lattice values (1 = close, 0 = far) mn_dist_lattice = env_padded_lattice - ( mn_dist_lattice - mn_dist_lattice . min ()) / mn_dist_lattice . max () Visualize distance lattice 1 f . visualize ( mn_dist_lattice , \"Entrance distance\" , \"../data/distance_field.png\" ) Write distance lattice to csv 1 2 3 # write distance lattice to csv csv_path = os . path . relpath ( \"../data/field_distance_entrance.csv\" ) mn_dist_lattice . to_csv ( csv_path ) Interpolate lowres lattice to highres 1 2 3 # loading highres lattice highres_lattice_path = os . path . relpath ( '../data/envelope_highres.csv' ) highres_lattice = tg . lattice_from_csv ( highres_lattice_path ) Define interpolation function 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def interpolate ( lowres_field ): # loading highres lattice highres_lattice_path = os . path . relpath ( '../data/envelope_highres.csv' ) highres_lat = tg . lattice_from_csv ( highres_lattice_path ) highres_lattice = highres_lat * 0 + 1 # line spaces x_space = np . linspace ( lowres_field . minbound [ 0 ], lowres_field . maxbound [ 0 ], lowres_field . shape [ 0 ]) y_space = np . linspace ( lowres_field . minbound [ 1 ], lowres_field . maxbound [ 1 ], lowres_field . shape [ 1 ]) z_space = np . linspace ( lowres_field . minbound [ 2 ], lowres_field . maxbound [ 2 ], lowres_field . shape [ 2 ]) # interpolation function interpolating_function = RegularGridInterpolator (( x_space , y_space , z_space ), lowres_field , bounds_error = False , fill_value = None ) # high_res lattice full_lattice = highres_lattice + 1 # sample point sample_points = full_lattice . centroids # interpolation interpolated_values = interpolating_function ( sample_points ) # lattice construction interpolated_lattice = tg . to_lattice ( interpolated_values . reshape ( highres_lattice . shape ), highres_lattice ) # nulling the unavailable cells interpolated_lattice *= highres_lattice return interpolated_lattice Interpolate closeness lattice 1 2 3 # Interpolate from lowres to highres highres_entrance = interpolate ( mn_dist_lattice ) highres_entrance_lattice = highres_entrance * highres_lattice Save interpolated field to csv 1 2 3 # save the interpolated distance field to csv csv_path = os . path . relpath ( \"../data/ent_acc.csv\" ) highres_entrance_lattice . to_csv ( csv_path ) Visualize highres field 1 f . visualize ( highres_entrance , \"Entrance distance\" , \"../data/ent_acc_highres.png\" ) Generate configuration Set conditions for the voxels 1 2 3 # this is an example configuration of looking only at the distance to the entrance highres_entrance_minmax = ( highres_entrance_lattice > 0.5 ) * ( highres_entrance_lattice != 0 ) highres_entrance_minmax . sum () Visualize the conditioned voxels 1 2 3 base_lattice = highres_entrance_minmax * highres_entrance_lattice f . visualize ( base_lattice , \"Entrance distance\" , \"distance_field_conf.png\" ) Save configuration to csv 1 2 3 # save the configuration to csv csv_path = os . path . relpath ( \"../data/configuration_distance_entrance.csv\" ) highres_entrance_minmax . to_csv ( csv_path ) Credits 1 2 3 4 5 __author__ = \"Shervin Azadi\" __license__ = \"MIT\" __version__ = \"1.0\" __url__ = \"https://github.com/shervinazadi/earthy_workshops\" __summary__ = \"Earthy Design Studio\"","title":"Distance"},{"location":"Scripts/distance_entrance/#distance-entrance","text":"Import packages 1 2 3 4 5 6 7 8 import os import topogenesis as tg import pyvista as pv import trimesh as tm import numpy as np import networkx as nx from scipy.interpolate import RegularGridInterpolator import resources.functions as f Import meshes 1 2 3 4 5 6 envelope_path = os . path . relpath ( '../data/new_envelope.obj' ) context_path = os . path . relpath ( '../data/immediate_context.obj' ) # load the mesh from file envelope_mesh = tm . load ( envelope_path ) context_mesh = tm . load ( context_path ) Import envelope lattice 1 2 3 4 5 6 7 8 9 10 11 # loading the lowres lattice from csv field_path = os . path . relpath ( \"../data/envelope_lowres.csv\" ) envelope_lattice = tg . lattice_from_csv ( field_path ) init_avail_lattice = tg . to_lattice ( np . copy ( envelope_lattice ), envelope_lattice ) # create a full lattice full with ones full_lattice = envelope_lattice * 0 + 1 # loading the highres lattice from csv field_path = os . path . relpath ( \"../data/envelope_highres.csv\" ) highres_lattice = tg . lattice_from_csv ( field_path ) Import street points + public transport points 1 2 street_transport_path = os . path . relpath ( '../data/mainstreet_publictransport.xyz.txt' ) street_transport = np . genfromtxt ( street_transport_path , delimiter = ',' )","title":"Distance entrance"},{"location":"Scripts/distance_entrance/#euclidean-distance-lattice","text":"Distance matrix 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # extracting the centroid of all voxels env_cens = envelope_lattice . centroids_threshold ( - 1 ) # initializing the distance matrix dist_m = [] # for each voxel ... for voxel_cen in env_cens : # initializing the distance vector (per each voxel) dist_v = [] # for each street point ... for street_transport_point in street_transport : # find the difference vector diff = voxel_cen - street_transport_point # raise the components to the power of two diff_p2 = diff ** 2 # sum the components diff_p2s = diff_p2 . sum () # compute the square root dist = diff_p2s ** 0.5 # add the distance to the distance vector dist_v . append ( dist ) # add the distance vector to the distance matrix dist_m . append ( dist_v ) # change the distance matrix type, from list to array dist_m = np . array ( dist_m )","title":"Euclidean distance lattice"},{"location":"Scripts/distance_entrance/#selecting-entrance-voxel","text":"Finding min distance to street and public 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # average of the distances to each point per voxel av_dist = [] for str_trans_points in dist_m : # calculate av_dist by taking the sum of the distances and divide by the amount of street points av_dist_vox = str_trans_points . sum () / len ( street_transport ) av_dist . append ( av_dist_vox ) # Find the voxel with the minimum average distance min_dist = np . min ( av_dist ) # Find the index of this voxel min_index = np . argmin ( av_dist ) # get the 3d location min_index_3d = np . unravel_index ( min_index , envelope_lattice . shape )","title":"Selecting entrance voxel"},{"location":"Scripts/distance_entrance/#import-the-stencils","text":"Stencil horizontal 1 2 3 4 5 6 7 8 # creating neighborhood definition 1 (horizontal) stencil_1 = tg . create_stencil ( \"von_neumann\" , 0 , 1 ) # setting the indices stencil_1 . set_index ([ 0 , 0 , 0 ], 0 ) stencil_1 . set_index ([ 0 , - 1 , 0 ], 1 ) stencil_1 . set_index ([ 0 , 1 , 0 ], 1 ) stencil_1 . set_index ([ - 1 , 0 , 0 ], 1 ) stencil_1 . set_index ([ 1 , 0 , 0 ], 1 ) Stencil vertical 1 2 3 4 5 6 # creating neighborhood definition 2 (vertical) stencil_2 = tg . create_stencil ( \"von_neumann\" , 0 , 1 ) # setting the indices stencil_2 . set_index ([ 0 , 0 , 0 ], 0 ) stencil_2 . set_index ([ 0 , 0 , - 1 ], 1 ) stencil_2 . set_index ([ 0 , 0 , 1 ], 1 )","title":"Import the stencils"},{"location":"Scripts/distance_entrance/#make-envelope-padded","text":"1 2 3 4 5 6 7 8 9 # make envelope padded to prevent seeing one side as a neighbour of the other side env_padded_array = np . pad ( envelope_lattice , 1 ) padded_minbound = envelope_lattice . minbound - envelope_lattice . unit env_padded_lattice = tg . to_lattice ( env_padded_array , minbound = padded_minbound , unit = envelope_lattice . unit ) # convert the location of the main entrance to the right envelope str_con_lattice = env_padded_lattice * False ent_sel_3d_ind_padded = tuple ( np . array ( np . unravel_index ( min_index , envelope_lattice . shape )) + 1 ) str_con_lattice [ ent_sel_3d_ind_padded ] = True","title":"Make envelope padded"},{"location":"Scripts/distance_entrance/#distance-lattice","text":"Retrieve neighbours 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # retrieve the neighbour list of each cell neighs_1 = str_con_lattice . find_neighbours ( stencil_1 ) neighs_2 = str_con_lattice . find_neighbours ( stencil_2 ) # set the maximum distance to sum of the size of the lattice in all dimensions. max_dist = np . sum ( str_con_lattice . shape ) # initialize the street network distance lattice with all the street cells as 0, and all other cells as maximum distance possible mn_dist_lattice = 1 - str_con_lattice mn_dist_lattice [ mn_dist_lattice == 1 ] = max_dist # flatten the distance lattice for easy access mn_dist_lattice_flat = mn_dist_lattice . flatten () # flatten the envelope lattice env_pad_lat_flat = env_padded_lattice . flatten () Giving every voxel values 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 # main loop for breath-first traversal for i in range ( 1 , max_dist ): # find the neighbours of the previous step next_step_1 = neighs_1 [ mn_dist_lattice_flat == i - 1 ] # find the unique neighbours next_unq_step_1 = np . unique ( next_step_1 . flatten ()) # check if the neighbours of the next step are inside the envelope validity_condition_1 = env_pad_lat_flat [ next_unq_step_1 ] # select the valid neighbours next_valid_step_1 = next_unq_step_1 [ validity_condition_1 ] # find the neighbours of the previous step next_step_2 = neighs_2 [ mn_dist_lattice_flat == i - 1 ] # find the unique neighbours next_unq_step_2 = np . unique ( next_step_2 . flatten ()) # check if the neighbours of the next step are inside the envelope validity_condition_2 = env_pad_lat_flat [ next_unq_step_2 ] # select the valid neighbours next_valid_step_2 = next_unq_step_2 [ validity_condition_2 ] # make a copy of the lattice to prevent overwriting in the memory mn_nex_dist_lattice_flat = np . copy ( mn_dist_lattice_flat ) # set the next step cells to the current distance mn_nex_dist_lattice_flat [ next_valid_step_2 ] = i + 1 # set the next step cells to the current distance mn_nex_dist_lattice_flat [ next_valid_step_1 ] = i # find the minimum of the current distance and previous distances to avoid overwriting previous steps mn_dist_lattice_flat = np . minimum ( mn_dist_lattice_flat , mn_nex_dist_lattice_flat ) # check how many of the cells have not been traversed yet filled_check = mn_dist_lattice_flat * env_pad_lat_flat == max_dist # if all the cells have been traversed, break the loop if filled_check . sum () == 0 : print ( i ) break # reshape and construct a lattice from the street network distance list mn_dist_lattice = mn_dist_lattice_flat . reshape ( mn_dist_lattice . shape ) mn_dist_lattice = mn_dist_lattice . astype ( float ) mn_dist_lattice *= env_padded_lattice # reverse the lattice values (1 = close, 0 = far) mn_dist_lattice = env_padded_lattice - ( mn_dist_lattice - mn_dist_lattice . min ()) / mn_dist_lattice . max ()","title":"Distance lattice"},{"location":"Scripts/distance_entrance/#visualize-distance-lattice","text":"1 f . visualize ( mn_dist_lattice , \"Entrance distance\" , \"../data/distance_field.png\" ) Write distance lattice to csv 1 2 3 # write distance lattice to csv csv_path = os . path . relpath ( \"../data/field_distance_entrance.csv\" ) mn_dist_lattice . to_csv ( csv_path )","title":"Visualize distance lattice"},{"location":"Scripts/distance_entrance/#interpolate-lowres-lattice-to-highres","text":"1 2 3 # loading highres lattice highres_lattice_path = os . path . relpath ( '../data/envelope_highres.csv' ) highres_lattice = tg . lattice_from_csv ( highres_lattice_path ) Define interpolation function 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def interpolate ( lowres_field ): # loading highres lattice highres_lattice_path = os . path . relpath ( '../data/envelope_highres.csv' ) highres_lat = tg . lattice_from_csv ( highres_lattice_path ) highres_lattice = highres_lat * 0 + 1 # line spaces x_space = np . linspace ( lowres_field . minbound [ 0 ], lowres_field . maxbound [ 0 ], lowres_field . shape [ 0 ]) y_space = np . linspace ( lowres_field . minbound [ 1 ], lowres_field . maxbound [ 1 ], lowres_field . shape [ 1 ]) z_space = np . linspace ( lowres_field . minbound [ 2 ], lowres_field . maxbound [ 2 ], lowres_field . shape [ 2 ]) # interpolation function interpolating_function = RegularGridInterpolator (( x_space , y_space , z_space ), lowres_field , bounds_error = False , fill_value = None ) # high_res lattice full_lattice = highres_lattice + 1 # sample point sample_points = full_lattice . centroids # interpolation interpolated_values = interpolating_function ( sample_points ) # lattice construction interpolated_lattice = tg . to_lattice ( interpolated_values . reshape ( highres_lattice . shape ), highres_lattice ) # nulling the unavailable cells interpolated_lattice *= highres_lattice return interpolated_lattice Interpolate closeness lattice 1 2 3 # Interpolate from lowres to highres highres_entrance = interpolate ( mn_dist_lattice ) highres_entrance_lattice = highres_entrance * highres_lattice Save interpolated field to csv 1 2 3 # save the interpolated distance field to csv csv_path = os . path . relpath ( \"../data/ent_acc.csv\" ) highres_entrance_lattice . to_csv ( csv_path ) Visualize highres field 1 f . visualize ( highres_entrance , \"Entrance distance\" , \"../data/ent_acc_highres.png\" )","title":"Interpolate lowres lattice to highres"},{"location":"Scripts/distance_entrance/#generate-configuration","text":"Set conditions for the voxels 1 2 3 # this is an example configuration of looking only at the distance to the entrance highres_entrance_minmax = ( highres_entrance_lattice > 0.5 ) * ( highres_entrance_lattice != 0 ) highres_entrance_minmax . sum () Visualize the conditioned voxels 1 2 3 base_lattice = highres_entrance_minmax * highres_entrance_lattice f . visualize ( base_lattice , \"Entrance distance\" , \"distance_field_conf.png\" ) Save configuration to csv 1 2 3 # save the configuration to csv csv_path = os . path . relpath ( \"../data/configuration_distance_entrance.csv\" ) highres_entrance_minmax . to_csv ( csv_path )","title":"Generate configuration"},{"location":"Scripts/distance_entrance/#credits","text":"1 2 3 4 5 __author__ = \"Shervin Azadi\" __license__ = \"MIT\" __version__ = \"1.0\" __url__ = \"https://github.com/shervinazadi/earthy_workshops\" __summary__ = \"Earthy Design Studio\"","title":"Credits"},{"location":"Scripts/distance_floor/","text":"Distance floor Import packages 1 2 3 4 5 6 7 8 9 10 import os import topogenesis as tg import pyvista as pv import trimesh as tm import numpy as np import networkx as nx from scipy.interpolate import RegularGridInterpolator import copy import resources.functions as f Import lattice 1 2 3 lattice_path = os . path . relpath ( \"../data/voxelized_envelope_lowres.csv\" ) envelope_lattice = tg . lattice_from_csv ( lattice_path ) full_lattice = envelope_lattice * 0 + 1 Create distance lattice Creat vertical adjacency matrix 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # get the amount of voxels in the z direction vox_count = len ( full_lattice [ 0 ][ 0 ]) # initialize an adjacency matrix adj_mtrx = np . zeros (( vox_count , vox_count )) # set the connecting values of the adjacency matrix to 1 for i in range ( vox_count ): if i == 0 : adj_mtrx [ i , i + 1 ] = 1 continue if i == vox_count - 1 : adj_mtrx [ i , i - 1 ] = 1 continue else : adj_mtrx [ i , i + 1 ] = 1 adj_mtrx [ i , i - 1 ] = 1 Turning into networkx datastructure and calculating distances 1 2 g = nx . from_numpy_array ( adj_mtrx ) dist_mtrx_vertical = nx . floyd_warshall_numpy ( g ) Selecting floor level and mapping distances between 0 and 1 1 2 3 4 5 floor_dist = dist_mtrx_vertical [ 0 - 4 ] # specified floor level max_valid = np . ma . masked_invalid ( floor_dist ) . max () # find max distance floor_dist_mapped = 1 - ( floor_dist / max_valid ) # map values between 0 and 1 with max distance Mapping the values to the full latice 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 floor_dist_mapped_full = [] height = len ( floor_dist_mapped ) # mapping the colomn of values to the full lattice for i in range ( len ( full_lattice ) * len ( full_lattice [ 0 ]) * len ( full_lattice [ 0 ][ 0 ])): floor_dist_mapped_full . append ( floor_dist_mapped [ i % height ]) # turning it into an np array floor_dist_mapped_full = np . array ( floor_dist_mapped_full ) # reshaping the array floor_dist_lattice_full = floor_dist_mapped_full . reshape ( full_lattice . shape ) # forming the lattice to the solar envelope floor_dist_lattice = floor_dist_lattice_full * full_lattice Visualize the floor level lattice 1 2 base_lattice = floor_dist_lattice * envelope_lattice f . visualize ( base_lattice , \"Ground floor closeness\" , \"../data/ground_dist_lowres.png\" ) Export to csv 1 2 3 4 5 floor_dist = floor_dist_lattice * envelope_lattice # save the lowres distance field to csv csv_path = os . path . relpath ( '../data/ground_field_lowres.csv' ) floor_dist . to_csv ( csv_path ) Interpolate lowres to highres Define interpolation function 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def interpolate ( lowres_field ): # loading highres lattice highres_lattice_path = os . path . relpath ( '../data/envelope_highres.csv' ) highres_lattice = tg . lattice_from_csv ( highres_lattice_path ) # line spaces x_space = np . linspace ( lowres_field . minbound [ 0 ], lowres_field . maxbound [ 0 ], lowres_field . shape [ 0 ]) y_space = np . linspace ( lowres_field . minbound [ 1 ], lowres_field . maxbound [ 1 ], lowres_field . shape [ 1 ]) z_space = np . linspace ( lowres_field . minbound [ 2 ], lowres_field . maxbound [ 2 ], lowres_field . shape [ 2 ]) # interpolation function interpolating_function = RegularGridInterpolator (( x_space , y_space , z_space ), lowres_field , bounds_error = False , fill_value = None ) # high_res lattice full_lattice = highres_lattice + 1 # sample point sample_points = full_lattice . centroids # interpolation interpolated_values = interpolating_function ( sample_points ) # lattice construction interpolated_lattice = tg . to_lattice ( interpolated_values . reshape ( highres_lattice . shape ), highres_lattice ) # nulling the unavailable cells interpolated_lattice *= highres_lattice return interpolated_lattice Interpolate closeness lattice 1 2 3 4 5 6 7 8 # Import the highres envelope highres_lattice_path = os . path . relpath ( '../data/envelope_highres.csv' ) highres_lattice = tg . lattice_from_csv ( highres_lattice_path ) # Interpolate from lowres to highres highres_ground_lattice = interpolate ( floor_dist_lattice ) # multiply by original highres_lattice to filter out the voxels outside the envelope highres_ground = highres_ground_lattice * highres_lattice Save interpolated field to csv 1 2 3 # save the interpolated distance field to csv csv_path = os . path . relpath ( \"../data/ground.csv\" ) highres_ground . to_csv ( csv_path ) Visualize highres field 1 f . visualize ( highres_ground , \"Ground floor closeness\" , \"../data/ground_acc_highres.png\" ) Credits 1 2 3 4 5 6 7 __author__ = \"Shervin Azadi\" __license__ = \"MIT\" __version__ = \"1.0\" __url__ = \"https://github.com/shervinazadi/earthy_workshops\" __summary__ = \"Earthy Design Studio\" Made with floor closeness notebook from group CUB3D","title":"Floor distance"},{"location":"Scripts/distance_floor/#distance-floor","text":"Import packages 1 2 3 4 5 6 7 8 9 10 import os import topogenesis as tg import pyvista as pv import trimesh as tm import numpy as np import networkx as nx from scipy.interpolate import RegularGridInterpolator import copy import resources.functions as f Import lattice 1 2 3 lattice_path = os . path . relpath ( \"../data/voxelized_envelope_lowres.csv\" ) envelope_lattice = tg . lattice_from_csv ( lattice_path ) full_lattice = envelope_lattice * 0 + 1","title":"Distance floor"},{"location":"Scripts/distance_floor/#create-distance-lattice","text":"Creat vertical adjacency matrix 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # get the amount of voxels in the z direction vox_count = len ( full_lattice [ 0 ][ 0 ]) # initialize an adjacency matrix adj_mtrx = np . zeros (( vox_count , vox_count )) # set the connecting values of the adjacency matrix to 1 for i in range ( vox_count ): if i == 0 : adj_mtrx [ i , i + 1 ] = 1 continue if i == vox_count - 1 : adj_mtrx [ i , i - 1 ] = 1 continue else : adj_mtrx [ i , i + 1 ] = 1 adj_mtrx [ i , i - 1 ] = 1 Turning into networkx datastructure and calculating distances 1 2 g = nx . from_numpy_array ( adj_mtrx ) dist_mtrx_vertical = nx . floyd_warshall_numpy ( g ) Selecting floor level and mapping distances between 0 and 1 1 2 3 4 5 floor_dist = dist_mtrx_vertical [ 0 - 4 ] # specified floor level max_valid = np . ma . masked_invalid ( floor_dist ) . max () # find max distance floor_dist_mapped = 1 - ( floor_dist / max_valid ) # map values between 0 and 1 with max distance Mapping the values to the full latice 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 floor_dist_mapped_full = [] height = len ( floor_dist_mapped ) # mapping the colomn of values to the full lattice for i in range ( len ( full_lattice ) * len ( full_lattice [ 0 ]) * len ( full_lattice [ 0 ][ 0 ])): floor_dist_mapped_full . append ( floor_dist_mapped [ i % height ]) # turning it into an np array floor_dist_mapped_full = np . array ( floor_dist_mapped_full ) # reshaping the array floor_dist_lattice_full = floor_dist_mapped_full . reshape ( full_lattice . shape ) # forming the lattice to the solar envelope floor_dist_lattice = floor_dist_lattice_full * full_lattice Visualize the floor level lattice 1 2 base_lattice = floor_dist_lattice * envelope_lattice f . visualize ( base_lattice , \"Ground floor closeness\" , \"../data/ground_dist_lowres.png\" ) Export to csv 1 2 3 4 5 floor_dist = floor_dist_lattice * envelope_lattice # save the lowres distance field to csv csv_path = os . path . relpath ( '../data/ground_field_lowres.csv' ) floor_dist . to_csv ( csv_path )","title":"Create distance lattice"},{"location":"Scripts/distance_floor/#interpolate-lowres-to-highres","text":"Define interpolation function 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def interpolate ( lowres_field ): # loading highres lattice highres_lattice_path = os . path . relpath ( '../data/envelope_highres.csv' ) highres_lattice = tg . lattice_from_csv ( highres_lattice_path ) # line spaces x_space = np . linspace ( lowres_field . minbound [ 0 ], lowres_field . maxbound [ 0 ], lowres_field . shape [ 0 ]) y_space = np . linspace ( lowres_field . minbound [ 1 ], lowres_field . maxbound [ 1 ], lowres_field . shape [ 1 ]) z_space = np . linspace ( lowres_field . minbound [ 2 ], lowres_field . maxbound [ 2 ], lowres_field . shape [ 2 ]) # interpolation function interpolating_function = RegularGridInterpolator (( x_space , y_space , z_space ), lowres_field , bounds_error = False , fill_value = None ) # high_res lattice full_lattice = highres_lattice + 1 # sample point sample_points = full_lattice . centroids # interpolation interpolated_values = interpolating_function ( sample_points ) # lattice construction interpolated_lattice = tg . to_lattice ( interpolated_values . reshape ( highres_lattice . shape ), highres_lattice ) # nulling the unavailable cells interpolated_lattice *= highres_lattice return interpolated_lattice Interpolate closeness lattice 1 2 3 4 5 6 7 8 # Import the highres envelope highres_lattice_path = os . path . relpath ( '../data/envelope_highres.csv' ) highres_lattice = tg . lattice_from_csv ( highres_lattice_path ) # Interpolate from lowres to highres highres_ground_lattice = interpolate ( floor_dist_lattice ) # multiply by original highres_lattice to filter out the voxels outside the envelope highres_ground = highres_ground_lattice * highres_lattice Save interpolated field to csv 1 2 3 # save the interpolated distance field to csv csv_path = os . path . relpath ( \"../data/ground.csv\" ) highres_ground . to_csv ( csv_path ) Visualize highres field 1 f . visualize ( highres_ground , \"Ground floor closeness\" , \"../data/ground_acc_highres.png\" )","title":"Interpolate lowres to highres"},{"location":"Scripts/distance_floor/#credits","text":"1 2 3 4 5 6 7 __author__ = \"Shervin Azadi\" __license__ = \"MIT\" __version__ = \"1.0\" __url__ = \"https://github.com/shervinazadi/earthy_workshops\" __summary__ = \"Earthy Design Studio\" Made with floor closeness notebook from group CUB3D","title":"Credits"},{"location":"Scripts/dynamic_fields/","text":"","title":"Dynamic"},{"location":"Scripts/functions/","text":"Functions Kopjes toevoegen Import ``` python linenums=\"1\" import os import topogenesis as tg import pyvista as pv import trimesh as tm import numpy as np import networkx as nx from scipy.interpolate import RegularGridInterpolator import matplotlib.pyplot as plt convert mesh to pv_mesh def tri_to_pv(tri_mesh): faces = np.pad(tri_mesh.faces, ((0, 0),(1,0)), 'constant', constant_values=3) pv_mesh = pv.PolyData(tri_mesh.vertices, faces) return pv_mesh def visualize(object_to_visualize, title, name_save): # load the context mesh context_path = os.path.relpath('../data/immediate_context.obj') context_mesh = tm.load(context_path) pv . set_plot_theme ( \"document\" ) # initiating the plotter p = pv . Plotter ( notebook = True ) # Create the spatial reference grid = pv . UniformGrid () # Set the grid dimensions : shape because we want to inject our values grid . dimensions = object_to_visualize . shape # The bottom left corner of the data set grid . origin = object_to_visualize . minbound # These are the cell sizes along each axis grid . spacing = object_to_visualize . unit # Add the data values to the cell data grid . point_arrays [ title ] = object_to_visualize . flatten ( order = \"F\" ) # Flatten the Lattice # adding the meshes p . add_mesh ( tri_to_pv ( context_mesh ), opacity = 0.1 , style = 'wireframe' ) # adding the volume opacity = np . array ( [ 0,0.6,0.6,0.6,0.6,0.6,0.6 ] ) p . add_volume ( grid , cmap = \"coolwarm\" , opacity = opacity , shade = False ) p . show ( screenshot = name_save ) def save_image(object_to_visualize, title, name_save): # load the context mesh context_path = os.path.relpath('../data/immediate_context.obj') context_mesh = tm.load(context_path) pv . set_plot_theme ( \"document\" ) # initiating the plotter p = pv . Plotter ( notebook = True ) # Create the spatial reference grid = pv . UniformGrid () # Set the grid dimensions : shape because we want to inject our values grid . dimensions = object_to_visualize . shape # The bottom left corner of the data set grid . origin = object_to_visualize . minbound # These are the cell sizes along each axis grid . spacing = object_to_visualize . unit # Add the data values to the cell data grid . point_arrays [ title ] = object_to_visualize . flatten ( order = \"F\" ) # Flatten the Lattice # adding the meshes p . add_mesh ( tri_to_pv ( context_mesh ), opacity = 0.1 , style = 'wireframe' ) # adding the volume opacity = np . array ( [ 0,0.6,0.6,0.6,0.6,0.6,0.6 ] ) p . add_volume ( grid , cmap = \"coolwarm\" , opacity = opacity , shade = False ) p . screenshot ( name_save ) def save_image_lattice(object_to_visualize, title, name_save, program): pv.set_plot_theme(\"document\") p = pv.Plotter(notebook=True) # Set the grid dimensions : shape + 1 because we want to inject our values on the CELL data grid = pv . UniformGrid () grid . dimensions = np . array ( object_to_visualize . shape ) + 1 # The bottom left corner of the data set grid . origin = object_to_visualize . minbound - object_to_visualize . unit * 0.5 # These are the cell sizes along each axis grid . spacing = object_to_visualize . unit # adding the boundingbox wireframe p . add_mesh ( grid . outline (), color = \"grey\" , label = \"Domain\" ) # adding axes p . add_axes () p . show_bounds ( grid = \"back\" , location = \"back\" , color = \"#777777\" ) # Add the data values to the cell data grid . cell_arrays [ title ] = object_to_visualize . flatten ( order = \"F\" ). astype ( int ) # Flatten the array ! # filtering the voxels agn_num = len ( program ) threshed = grid . threshold ( [ -0.1, agn_num - 0.9 ] ) # adding the voxels p . add_mesh ( threshed , show_edges = True , opacity = 1.0 , show_scalar_bar = False ) p . screenshot ( name_save ) ```","title":"Functions"},{"location":"Scripts/functions/#functions","text":"","title":"Functions"},{"location":"Scripts/functions/#kopjes-toevoegen","text":"Import ``` python linenums=\"1\" import os import topogenesis as tg import pyvista as pv import trimesh as tm import numpy as np import networkx as nx from scipy.interpolate import RegularGridInterpolator import matplotlib.pyplot as plt","title":"Kopjes toevoegen"},{"location":"Scripts/functions/#convert-mesh-to-pv_mesh","text":"def tri_to_pv(tri_mesh): faces = np.pad(tri_mesh.faces, ((0, 0),(1,0)), 'constant', constant_values=3) pv_mesh = pv.PolyData(tri_mesh.vertices, faces) return pv_mesh def visualize(object_to_visualize, title, name_save): # load the context mesh context_path = os.path.relpath('../data/immediate_context.obj') context_mesh = tm.load(context_path) pv . set_plot_theme ( \"document\" ) # initiating the plotter p = pv . Plotter ( notebook = True ) # Create the spatial reference grid = pv . UniformGrid () # Set the grid dimensions : shape because we want to inject our values grid . dimensions = object_to_visualize . shape # The bottom left corner of the data set grid . origin = object_to_visualize . minbound # These are the cell sizes along each axis grid . spacing = object_to_visualize . unit # Add the data values to the cell data grid . point_arrays [ title ] = object_to_visualize . flatten ( order = \"F\" ) # Flatten the Lattice # adding the meshes p . add_mesh ( tri_to_pv ( context_mesh ), opacity = 0.1 , style = 'wireframe' ) # adding the volume opacity = np . array ( [ 0,0.6,0.6,0.6,0.6,0.6,0.6 ] ) p . add_volume ( grid , cmap = \"coolwarm\" , opacity = opacity , shade = False ) p . show ( screenshot = name_save ) def save_image(object_to_visualize, title, name_save): # load the context mesh context_path = os.path.relpath('../data/immediate_context.obj') context_mesh = tm.load(context_path) pv . set_plot_theme ( \"document\" ) # initiating the plotter p = pv . Plotter ( notebook = True ) # Create the spatial reference grid = pv . UniformGrid () # Set the grid dimensions : shape because we want to inject our values grid . dimensions = object_to_visualize . shape # The bottom left corner of the data set grid . origin = object_to_visualize . minbound # These are the cell sizes along each axis grid . spacing = object_to_visualize . unit # Add the data values to the cell data grid . point_arrays [ title ] = object_to_visualize . flatten ( order = \"F\" ) # Flatten the Lattice # adding the meshes p . add_mesh ( tri_to_pv ( context_mesh ), opacity = 0.1 , style = 'wireframe' ) # adding the volume opacity = np . array ( [ 0,0.6,0.6,0.6,0.6,0.6,0.6 ] ) p . add_volume ( grid , cmap = \"coolwarm\" , opacity = opacity , shade = False ) p . screenshot ( name_save ) def save_image_lattice(object_to_visualize, title, name_save, program): pv.set_plot_theme(\"document\") p = pv.Plotter(notebook=True) # Set the grid dimensions : shape + 1 because we want to inject our values on the CELL data grid = pv . UniformGrid () grid . dimensions = np . array ( object_to_visualize . shape ) + 1 # The bottom left corner of the data set grid . origin = object_to_visualize . minbound - object_to_visualize . unit * 0.5 # These are the cell sizes along each axis grid . spacing = object_to_visualize . unit # adding the boundingbox wireframe p . add_mesh ( grid . outline (), color = \"grey\" , label = \"Domain\" ) # adding axes p . add_axes () p . show_bounds ( grid = \"back\" , location = \"back\" , color = \"#777777\" ) # Add the data values to the cell data grid . cell_arrays [ title ] = object_to_visualize . flatten ( order = \"F\" ). astype ( int ) # Flatten the array ! # filtering the voxels agn_num = len ( program ) threshed = grid . threshold ( [ -0.1, agn_num - 0.9 ] ) # adding the voxels p . add_mesh ( threshed , show_edges = True , opacity = 1.0 , show_scalar_bar = False ) p . screenshot ( name_save ) ```","title":"convert mesh to pv_mesh"},{"location":"Scripts/green_view/","text":"","title":"Green"},{"location":"Scripts/grow_agents/","text":"Initialize and grown agents (ABM) Load required libraries 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # !pip install pyvista==0.28.1 ipyvtklink import os import topogenesis as tg import pyvista as pv import trimesh as tm import pandas as pd import numpy as np import copy import random from sklearn.cluster import KMeans np . random . seed ( 0 ) import resources.dynamic_fields as df import resources.functions as func # convert mesh to pv_mesh def tri_to_pv ( tri_mesh ): faces = np . pad ( tri_mesh . faces , (( 0 , 0 ),( 1 , 0 )), 'constant' , constant_values = 3 ) pv_mesh = pv . PolyData ( tri_mesh . vertices , faces ) return pv_mesh Define the neighborhood (stencil) Stencil: horizontal 1 2 3 4 5 6 7 8 9 10 11 # creating neighborhood definition 1 stencil = tg . create_stencil ( \"von_neumann\" , 1 , 1 ) # setting the indices stencil . set_index ([ 0 , 0 , 0 ], 0 ) # creating neighborhood definition 1 stencil_hor = tg . create_stencil ( \"von_neumann\" , 1 , 1 ) # setting the indices stencil_hor . set_index ([ 0 , 0 , 0 ], 0 ) stencil_hor . set_index ([ 0 , 0 , 1 ], 0 ) stencil_hor . set_index ([ 0 , 0 , - 1 ], 0 ) Setup the environment Load the envelope lattice as the availability lattice 1 2 3 4 5 6 7 8 9 10 11 # loading the lattice from csv lattice_path = os . path . relpath ( '../data/envelope_highres.csv' ) avail_lattice = tg . lattice_from_csv ( lattice_path ) init_avail_lattice = tg . to_lattice ( np . copy ( avail_lattice ), avail_lattice ) # loading the lattice from csv field_path = os . path . relpath ( \"../data/envelope_lowres.csv\" ) envelope_lattice = tg . lattice_from_csv ( field_path ) #init_avail_lattice = tg.to_lattice(np.copy(envelope_lattice), envelope_lattice) full_lattice = envelope_lattice * 0 + 1 Load program 1 2 3 4 5 6 7 8 program_full = pd . read_csv ( \"../data/program_req.csv\" ) #program_full program_complete = program_full . drop ([ \"vox_amount\" ], 1 ) #program_complete program_prefs = program_complete . drop ([ \"space_name\" , \"space_id\" ], 1 ) #program_prefs","title":"Initialization"},{"location":"Scripts/grow_agents/#initialize-and-grown-agents-abm","text":"Load required libraries 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # !pip install pyvista==0.28.1 ipyvtklink import os import topogenesis as tg import pyvista as pv import trimesh as tm import pandas as pd import numpy as np import copy import random from sklearn.cluster import KMeans np . random . seed ( 0 ) import resources.dynamic_fields as df import resources.functions as func # convert mesh to pv_mesh def tri_to_pv ( tri_mesh ): faces = np . pad ( tri_mesh . faces , (( 0 , 0 ),( 1 , 0 )), 'constant' , constant_values = 3 ) pv_mesh = pv . PolyData ( tri_mesh . vertices , faces ) return pv_mesh","title":"Initialize and grown agents (ABM)"},{"location":"Scripts/grow_agents/#define-the-neighborhood-stencil","text":"Stencil: horizontal 1 2 3 4 5 6 7 8 9 10 11 # creating neighborhood definition 1 stencil = tg . create_stencil ( \"von_neumann\" , 1 , 1 ) # setting the indices stencil . set_index ([ 0 , 0 , 0 ], 0 ) # creating neighborhood definition 1 stencil_hor = tg . create_stencil ( \"von_neumann\" , 1 , 1 ) # setting the indices stencil_hor . set_index ([ 0 , 0 , 0 ], 0 ) stencil_hor . set_index ([ 0 , 0 , 1 ], 0 ) stencil_hor . set_index ([ 0 , 0 , - 1 ], 0 )","title":"Define the neighborhood (stencil)"},{"location":"Scripts/grow_agents/#setup-the-environment","text":"Load the envelope lattice as the availability lattice 1 2 3 4 5 6 7 8 9 10 11 # loading the lattice from csv lattice_path = os . path . relpath ( '../data/envelope_highres.csv' ) avail_lattice = tg . lattice_from_csv ( lattice_path ) init_avail_lattice = tg . to_lattice ( np . copy ( avail_lattice ), avail_lattice ) # loading the lattice from csv field_path = os . path . relpath ( \"../data/envelope_lowres.csv\" ) envelope_lattice = tg . lattice_from_csv ( field_path ) #init_avail_lattice = tg.to_lattice(np.copy(envelope_lattice), envelope_lattice) full_lattice = envelope_lattice * 0 + 1 Load program 1 2 3 4 5 6 7 8 program_full = pd . read_csv ( \"../data/program_req.csv\" ) #program_full program_complete = program_full . drop ([ \"vox_amount\" ], 1 ) #program_complete program_prefs = program_complete . drop ([ \"space_name\" , \"space_id\" ], 1 ) #program_prefs","title":"Setup the environment"},{"location":"Scripts/noise/","text":"","title":"Noise"},{"location":"Scripts/shadow/","text":"","title":"Shadow"},{"location":"Scripts/shafts_corridors/","text":"","title":"Shafts"},{"location":"Scripts/sun_acc/","text":"","title":"Sun"},{"location":"Scripts/svf/","text":"","title":"SVF"},{"location":"Scripts/voxelization/","text":"","title":"Voxelization"},{"location":"documenting/folder_structure/","text":"Folder Structure The folders in student projects should strictly follow the structure of the folders in this repository. The main folders are four assignment folder (corresponding to each assignment) and one folder for final deliverables of your project. In general, the process sub-folders include all the necessary code, notebook, files, and models that you have used to achieve the final product of that assignment. It also includes document that represent the process of the assignment such as flowcharts, diagrams and pseudo-codes. The product sub-folder sh Here is run down of the overall structure: A1_Planning Process Product A2_Configuring Process Product A3_Massing Process Product A4_Forming Process Product Final_Deliverables Here you will include all the final deliverables of your project. docs Here you will write and edit the source of your documentation in MarkDown . An example is included in the template to help you begin documenting your project. site you should leave this directory empty. It will be filled by automatic documentation generator MkDocs","title":"Folder Structure"},{"location":"documenting/folder_structure/#folder-structure","text":"The folders in student projects should strictly follow the structure of the folders in this repository. The main folders are four assignment folder (corresponding to each assignment) and one folder for final deliverables of your project. In general, the process sub-folders include all the necessary code, notebook, files, and models that you have used to achieve the final product of that assignment. It also includes document that represent the process of the assignment such as flowcharts, diagrams and pseudo-codes. The product sub-folder sh Here is run down of the overall structure: A1_Planning Process Product A2_Configuring Process Product A3_Massing Process Product A4_Forming Process Product Final_Deliverables Here you will include all the final deliverables of your project. docs Here you will write and edit the source of your documentation in MarkDown . An example is included in the template to help you begin documenting your project. site you should leave this directory empty. It will be filled by automatic documentation generator MkDocs","title":"Folder Structure"},{"location":"documenting/guidelines/","text":"Guidelines File Size : No file bigger than 50mb is recommended. No file bigger than 100mb is allowed. Folder Structure : Do not change the folder structure. You can sub-folders to the existing folders if you want but you shall not change the existing overall structure Duplicates : Do NOT include duplicates in your files. Naming Convention : Avoid using special characters or spaces in file and folder names. Instead, use \"_\" to separate words in the names. Geometric Models (.3dm, .obj, etc) should be compressed before being added to repository. Video and Animation files should not be included the repository. They should be uploaded to online video services (YouTube, Vimeo, etc). You should embed those video link in your documentation. (GIF files are allowed in your repo)","title":"Guidelines"},{"location":"documenting/guidelines/#guidelines","text":"File Size : No file bigger than 50mb is recommended. No file bigger than 100mb is allowed. Folder Structure : Do not change the folder structure. You can sub-folders to the existing folders if you want but you shall not change the existing overall structure Duplicates : Do NOT include duplicates in your files. Naming Convention : Avoid using special characters or spaces in file and folder names. Instead, use \"_\" to separate words in the names. Geometric Models (.3dm, .obj, etc) should be compressed before being added to repository. Video and Animation files should not be included the repository. They should be uploaded to online video services (YouTube, Vimeo, etc). You should embed those video link in your documentation. (GIF files are allowed in your repo)","title":"Guidelines"},{"location":"documenting/instructions/","text":"Documenting Instructions Installation Install Conda You can install Anaconda or Miniconda to install conda package manager (if you don't know the difference you should install anaconda). Create documentation environment Now we need to create the appropriate environment for documenting by installing all the necessary tools. To do so we have provided you an environment droplet, which is a recipe for a series of installations that create the aforementioned environment. For that, after directing to the root folder of this project where the environment droplet ( environment.yml ) is located, you need to run the following command: conda env create -f environment.yml Start Work on Documentation After finishing your work on documentation you need to shutdown the server and deactivate the environment. Activate the Environment Now that you have created the appropriate environment, you need to activate the environment to be able to work inside it. For that, as you are in the root folder of this project, you need to run the following command: conda activate spatial_computing_docs If the command line is now indicating the name of the environment in parenthesis, it means that the environment is activated. Similar to this ( spatial_computing_docs ) { your username } @ { your computer name } spatial_computing_project_template % Run the Local Server Now that the environment is activated, we need to run the local server to be able to see the result of changes in the local version of the documentation website. For that, run the following command: mkdocs serve After running this command, if the server has started to work successfully, you should see the following line in the command line: INFO - Serving on http://127.0.0.1:8000 This means that the server is accessible at http://127.0.0.1:8000 . If you open your browser and go this link you should see a local version of the site. Writing Your Documentation In the documenting process you need to head to the docs folder and edit the .md (markdown) files, since the website is build from these files. In the root of this project, you can edit the configurations of your project in mkdocs.yml file: Adding o removing pages Add markdown extensions . Some of the useful extensions: arithmatex for writing mathematics highlight for code highlighting Customizing the looks of your documentation Adding MkDocs Plugins , such as: mknotebooks for including python notebooks in the documentations Finish Work on Documentation Server Shut Down To shutdown the server, you need to press Ctrl + C in the command line. The following should appear in the command line: INFO - Shutting down... Deactivate Environment After shutting down your server the command line is back to the normal state and you can run commands again. To deactivate your environment you need to run the following command: conda deactivate Deployment of the Documentation Site Build and Deploy to deploy your documentation website, you need to run the following command in the root of this repository: mkdocs gh-deploy This command will create a new branch in your repository called gh-pages and build your site in it. It will then push the new branch to your remote repository automatically. It will also create a site folder in your root directory containing all of your site files. Since this folder is added .gitignore file, it won't be committed or pushed to the remote repository. Setup GitHub Pages For the first time, you need to configure the GitHub Pages service on your GitHub repository so it wil automatically build your documentation website whenever you deploy your site. To do this: Go to your repository setting, got GitHub Pages section, select gh-pages branch, select /(root) location, click on the save button. The setting page will refresh, and now if you go to the address that is provided at the GitHub Pages section, Wola, here is your documentation!","title":"Instructions"},{"location":"documenting/instructions/#documenting-instructions","text":"","title":"Documenting Instructions"},{"location":"documenting/instructions/#installation","text":"","title":"Installation"},{"location":"documenting/instructions/#install-conda","text":"You can install Anaconda or Miniconda to install conda package manager (if you don't know the difference you should install anaconda).","title":"Install Conda"},{"location":"documenting/instructions/#create-documentation-environment","text":"Now we need to create the appropriate environment for documenting by installing all the necessary tools. To do so we have provided you an environment droplet, which is a recipe for a series of installations that create the aforementioned environment. For that, after directing to the root folder of this project where the environment droplet ( environment.yml ) is located, you need to run the following command: conda env create -f environment.yml","title":"Create documentation environment"},{"location":"documenting/instructions/#start-work-on-documentation","text":"After finishing your work on documentation you need to shutdown the server and deactivate the environment.","title":"Start Work on Documentation"},{"location":"documenting/instructions/#activate-the-environment","text":"Now that you have created the appropriate environment, you need to activate the environment to be able to work inside it. For that, as you are in the root folder of this project, you need to run the following command: conda activate spatial_computing_docs If the command line is now indicating the name of the environment in parenthesis, it means that the environment is activated. Similar to this ( spatial_computing_docs ) { your username } @ { your computer name } spatial_computing_project_template %","title":"Activate the Environment"},{"location":"documenting/instructions/#run-the-local-server","text":"Now that the environment is activated, we need to run the local server to be able to see the result of changes in the local version of the documentation website. For that, run the following command: mkdocs serve After running this command, if the server has started to work successfully, you should see the following line in the command line: INFO - Serving on http://127.0.0.1:8000 This means that the server is accessible at http://127.0.0.1:8000 . If you open your browser and go this link you should see a local version of the site.","title":"Run the Local Server"},{"location":"documenting/instructions/#writing-your-documentation","text":"In the documenting process you need to head to the docs folder and edit the .md (markdown) files, since the website is build from these files. In the root of this project, you can edit the configurations of your project in mkdocs.yml file: Adding o removing pages Add markdown extensions . Some of the useful extensions: arithmatex for writing mathematics highlight for code highlighting Customizing the looks of your documentation Adding MkDocs Plugins , such as: mknotebooks for including python notebooks in the documentations","title":"Writing Your Documentation"},{"location":"documenting/instructions/#finish-work-on-documentation","text":"","title":"Finish Work on Documentation"},{"location":"documenting/instructions/#server-shut-down","text":"To shutdown the server, you need to press Ctrl + C in the command line. The following should appear in the command line: INFO - Shutting down...","title":"Server Shut Down"},{"location":"documenting/instructions/#deactivate-environment","text":"After shutting down your server the command line is back to the normal state and you can run commands again. To deactivate your environment you need to run the following command: conda deactivate","title":"Deactivate Environment"},{"location":"documenting/instructions/#deployment-of-the-documentation-site","text":"","title":"Deployment of the Documentation Site"},{"location":"documenting/instructions/#build-and-deploy","text":"to deploy your documentation website, you need to run the following command in the root of this repository: mkdocs gh-deploy This command will create a new branch in your repository called gh-pages and build your site in it. It will then push the new branch to your remote repository automatically. It will also create a site folder in your root directory containing all of your site files. Since this folder is added .gitignore file, it won't be committed or pushed to the remote repository.","title":"Build and Deploy"},{"location":"documenting/instructions/#setup-github-pages","text":"For the first time, you need to configure the GitHub Pages service on your GitHub repository so it wil automatically build your documentation website whenever you deploy your site. To do this: Go to your repository setting, got GitHub Pages section, select gh-pages branch, select /(root) location, click on the save button. The setting page will refresh, and now if you go to the address that is provided at the GitHub Pages section, Wola, here is your documentation!","title":"Setup GitHub Pages"}]}